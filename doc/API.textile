h1. Model

openBarter defines a  market implementing the same economic mecanisms as a traditional market but allows exchange between more than two partners. The competition incorporates collaboration of partners. This way, cooperation is fostered. The second difference is that it does not require a central monetary standard to define the value of goods and compare prices. 
Finally the low liquidity of barter is the historical reason why money expended and barter decreased. By allowing exchanges with more than two partners the barter market becomes nearly as liquid as traditional market using money.

h2. Definitions

+Value+
A value is a couple (quantity,quality), where quality is a name, and quantity is an integer. It can be used to define an amount of mineral, of pollution, or of money. The owner of this value uses the market to exchange it.

+Exchange+
The market allows exchanges between two partners or more. An exchange forms a cycle of partners where each provides a value and receives an other value. An exchange with more than two partners is *non-bilateral*.

+Price+
The price is defined for a couple (quality provided,quality required). It is the ratio between provided quantity and received quantity. 

+Agreement on price+
Partners agree on their prices when the product of their prices equals to 1. When this condition is not met a barter is required.

+bid+
It is an unilateral commitment to exchange a value for another quality at a given price. A bid is defined by a value provided, the quality of the value required and a price. Two bids match when the quality provided by one equals the quality required by the other. When some bid matchings form a cycle, an exchange can be formed from it.

+best price rule+
It is used to select  the best among possible exchange cycles. The best cycle is the one having the maximum product of prices.

+barter+
When partners do not agree on price, an automatic barter is performed by openBarter where prices are divided by the geometric mean of prices. This division makes the product of prices equal to 1.

h2. Economics

For an exchange between a seller providing 10 Kg of appels in exchange of 20 pounds, the price is 2 pounds/Kg. If a seller provides a quantity *g* of goods to a buyer in exchange of a quantity *m* of money, the traditional definition of price is *p* = *m* / *g*.
Before agreement,  buyer and seller have usually different ideas of prices, we note the buyer price *bp* and the seller price *sp*.

Using the definition of price given earlier (a ratio between provided and received quantities) the buyer price is  *m* / *g*, we note it *bP*.  The seller price is *g* / *m*, we note it *sP*. We can remarque that *bP* = *bp* and *sP* = 1/ *sp*.

+Agreement+
Agreement on price between the buyer and the seller exists when *bp* = *sp*. An equivalent statement using our definition of price is *bP* = 1/ *sP* or *bP* * *sP* = 1. It is the definition of agreement given earlier applied to the bilateral case.

+Competition+
Using the traditional definition of price, the best price rule is for the buyer the minimum *sp*, and for the seller the maximum *bp*. Using the new definition of price; since *sP* = 1/ *sp* and *bP* = *bp*; it is the maximum *sP* and the maximum *pB*, or the maximum of the product *bP* * *sP*. It is the definition of the best price rule given earlier applied to the bilateral case.

+Barter+
Barter is required when buyer and seller do not agree on their prices *bp* and *sp*. The automatic barter defines earlier expressed using *bp* and *sp* is simply their geometric mean. This represents for each participant the same ratio between initial and final price. This is a simple way to balance offerts provided by partners.

Finally the model is a generalization of the rules of market to non-bilateral exchanges.

h1. Implementation

The market is seen as a directed graph where bids define nodes, and matchings between bids define arrows. This graph is maintained acyclic by transforming cycles into draft agreements as soon as they appear. Each time a bid is added, a competition occurs between possible cycles when more than one cycles are found. Draft agreements are produced from these cycles. Values corresponding to these agreements reduce values of bids in such a way that cycles desappear.

Even if cycles should never appear an error detection is done when the graph is explored. If a cycle is found a correction is performed locally minimizing the consequences of the error.

h2.  Technical overview

openBarter is an extension of postgreSql. Stored procedures act on a model representing qualities, owners, values, and draft exchange agreement.

The main time consuming primitives of the server are:
* read the best price for a couple of qualities requested and provided,
* make an bid. 
A single simplifying hypothesis is used to limit computation load: the number of partners of contracts is limited to 8. This explains why the liquidity of openBarter is not strictly the same as on a bilateral stock market. 

h2. Users

Users of openBarter are:
* the market, a central service where owner anthenticate and act to exchange their goods,
* depositories,
Depositories are external institutions managing ownership of values.

A user of openBarter is also a user for postgreSql, and all authentification capabilities of postgreSql can be used to inforce security of openBarter.

h2.  API of openBarter

Users of openBarter act through stored procedures that must be integrated in transactions by the client.
A depository can just create a quality, and move values in and out of openBarter.
Other procedures are used by the market.

A quality is declared and used by a single depository in odrer to separate responsibility of ownership management of each quality.
Even when value ownerships are exchanged, the depository that guaranties these values does not change.

h3. create a quality

+prototype+

bc. int ob_fcreate_quality(_name text)

+function+

records a new quality with the name: @user>_name@ where @user@ is the database user.	

Returns:
* 0 when the quality is created,
* <0 on error.

+example+

bc. select * from ob_fcreate_quality('sand')
	
h3. credit account

+prototype+

bc. int ob_fadd_account(_owner text,_quality text,_qtt int8)


+conditions+
* quality  exist,
* qtt >=0.
		
+actions+
moves the value from 	to	owners_account[_owner,_quality]
account and owner are created when they do not exist. The movement is recorded.
			
Returns:
* 0 when the account is credited,
* < 0 on error.

h3. debit account

+prototype+

bc. int ob_fasub_account(_owner text,_quality text,_qtt int8)

+conditions+
* owner and quality  exist,
* qtt >=0 and <= qtt of the account[_owner,_quality ]
		
+actions+
removes the value from 	to	owners_account[_owner,_quality]
Account is deleted when empty. The movement is recorded.
			
Returns:
* 0 when the account is debited,
* < 0 on error.

h3. insert a bid

+prototype+

bc.  int8 ob_finsert_bid(_owner text,_qualityprovided text,qttprovided int8,_qttrequired int8,_qualityrequired text)

+conditions+
* _owner exists,
* _qualityprovided and _qualityrequired defined,
* _qttprovided >0,
* _qttrequired >0.

+action+
makes a new bid based on a new stock_D.

returns:
*		the number of drafts created (>=0),
*		< 0 error.

h3. insert a bid based on an other

+prototype+

bc.  int8  ob_finsert_sbid(_bid_id int8,_qttprovided int8,_qttrequired int8,_qualityrequired text)

+conditions+
* _bid_id exists,
* _qttprovided >0,
* _qttrequired >0,
* _qualityrequired is defined.

+action+
makes a new bid based on a stock_D used by the bid bid_id.

returns:
*		the number of drafts created (>=0),
*		< 0 error.

h3. delete a bid

+prototype+

bc. ob_fdelete_bid(bid_id int8) 

+conditions+
* the bid exists

+actions+
Delete bid and related drafts.
Delete related stock_S if it is not related to an other bid.
 The quantity of this stock_S is moved back to the account.
	
A given stock_S is deleted by the ob_fdelete_bid() of the last bid it references.

h3. accept a draft

+prototype+

bc.  int ob_faccept_draft(draft_id int8,owner text)

+conditions+
* draft_id exists with status D

returns:
*		0 the draft is not yet accepted by all partners, 
*		1 the draft is executed,
*		< 0 error.

h3. refuse a draft

+prototype+

bc.  int ob_frefuse_draft(draft_id int8,owner text)

+conditions+
* draft_id exists with status D

+action+
the draft D is cancelled.
quantities of stock_D(A value booked for a special draft) booked for this draft are moved back to stock_S of bids

returns:
*		1 the draft is cancelled,
*		< 0 error.

h3. update price tables

+prototype+

bc. int ob_fbatch_omega()

utility calling ob_fread_omega(nr,nf) for the couple (nr,nf) that needs refresh the most:
* a couple (nr,nf) such as ob_tomega[nr,nf] does not exist,
* if not found, oldest couple (cflags&1=0),
*  if not found,  oldest couple such as (cflags&1=1)
	
Should be called by a cron.

h3. statisticts

+prototype+

bc. ob_tret_stats ob_fstats()

+function+

gives general informations about the model:

|_. Column|_.Type|_. Meaning |
| *mean_time_drafts*| int8|	mean of delay of drafts|
| *nb_drafts*| int8 |	number of drafts|
| *nb_noeuds*| int8 |	number of bids|
| *nb_stocks*| int8 |	number of stocks|
| *nb_stocks_s*| int8 |	number of stocks type=S|
| *nb_stocks_d*| int8 |	number of stocks type=D|
| *nb_stocks_a*| int8 |	number of stocks type=A|
| *nb_qualities*| int8 |	number of qualities|
| *nb_owners*| int8 |	number of owners	|

all following columns should be zero

|_. Column|_.Type|_. Meaning |
| *unbananced_qualities*| int8 |	number of qualities with accounting problems|
| *corrupted_draft*| int8 | number of unconsistant drafts|
| *corrupted_stock_s*| int8 | number of stocks_S not related to a bid|
| *corrupted_stock_a*| int8 |	number of couples (quality,owner) where stocks_A is not unique |

+example+

bc. select * from ob_fstats()

h2. Views

h3. ob_vowned


Gives quantity  owned for each couple (quality,owner).


|_. Column|_.Type|_. Meaning |
| *qown*	|text|	owner of the quality|
| *qname*	|text|		quality name|
| *owner*|text|	 	owners name|
| *qtt*	|int8|	sum(qtt) for couples (quality,owner)|
| *created*	|timestamp|min(created)|
| *updated*|timestamp|	max(updated?updated:created)|
		
+examples+

bc. SELECT * FROM ob_vowned WHERE owner='jack'

total values owned by the owner 'jack'

bc. SELECT * FROM ob_vowned WHERE qown='bankofcuba'

total values of owners for qualities of 'bankofcuba'

bc. SELECT o.qname FROM ob_vowned o INNER JOIN ob_tquality on q.name=o.qname
GROUP BY o.qname WHERE q.qtt != 0 

returns 0 lines when accounting is correct	for each quality

h3. ob_valance

List of values 

|_. Column|_.Type|_. Meaning |
| *qown*	|text|	owner of the quality|
| *qname*	|text|	quality name|
| *qtt*|int8|		sum(qtt) for this quality|
| *created*	|timestamp|min(created)|
| *updated*|timestamp|	max(updated?updated:created)|


examples:

bc. SELECT * FROM ob_vbalance WHERE qown='bankofcuba'

Total values owned by the depositary 'bankofcuba'
	

h3. ob_vdraft

list of drafts where the owner is partner.

|_. Column|_.Type|_. Meaning |
| *did*	|int8|id of draft|	
| *status*	|char	|always D |
| *owner*	|text|	owner providing the value|
| *cntcommit*	|int|number of commits of the draft|
| *flags*|int4|		bit 0 set when accepted by owner; bit 1 set when refuse by owner|
| *created*	|	timestamp||

usage:

bc. SELECT * FROM ob_vdraft WHERE owner='paul'
	
list of drafts for the owner 'paul'
	
	
h3. ob_vbid

returns a list of bids.

|_. Column|_.Type|_. Meaning |
| *id*		|int8|	id of bid		|
| *owner*		|text|	name of owner|
| *required_quality*|text||
| *required quantity*|int8||
| *omega*	|float|the ration provided_quantity/required quantity|
| *provided quality*|text||
| *provided_quantity*|int8||
| *sid*	|	int8|	stock id of the bid|
| *qtt*	|int8|	sum(qtt)|
| *created*|timestamp||
	
usage:

bc. SELECT * FROM ob_vbid WHERE owner='luc'

list of bids of the owner 'luc'
		

h3. ob_vmvt

returns a list of movements related to the owner.

|_. Column|_.Type|_. Meaning |
| *id*|int8|id of the movement. |
|*did*|int8| When an agreement is executed, all movements produced have the same did. It is not NULL for a draft executed even if this draft where deleted. It is NULL when the movement is not due to the execution of an agreement.|
|*provider*	|text|name of provider|
| *nat*	|text|	quality of moved value|
| *qtt*	|int8|	quantity moved value|
| *receiver*	|text| name of receiver |
| *created*	|text|	timestamp |
	
usage:

bc. SELECT * from ob_vmvt where 'luc' in (provider,receiver)

list of movements for this owner.

{glossary:style=disc}

