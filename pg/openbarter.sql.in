/*
A database is created:
	createdb market
	psql -dmarket
	
	revoke all on database from public;
	\q
	
Before the model is settled, roles market and depositary should be created.
	CREATE ROLE noright LOGIN;
	CREATE ROLE market;
	CREATE ROLE depositary;
	CREATE ROLE admin LOGIN;
	GRANT depositary to market;

--------------------------------------------------------------------------------
TYPES
*******

postgres			C		nb bytes
*********************************************************
int8,bigint,bigserial 		int64		8, signed interger
int4,integer			int32		4, signed interger
int2,smallint			int16		2, signed interger
double precision		float8		8, long float
char				char		1 	(postgres.h)

STOCK MOVEMENTS
*********************
addaccount	stockA[market] -=qtt	stockA[owner] +=qtt
subaccount	stockA[market] +=qtt	stockA[owner] -=qtt
create stock	stockA[owner]  -=qtt		stockS[owner] +=qtt
create draft	stockS[owner]  -=qtt		stockD[owner] +=qtt

execut draft	stockD[owner]  -=qtt	
		stockA[newowner] =+qtt (commit.sid_src -> commit.sid_dst)
		
refuse draft	stockD[owner]  -=qtt	
		stockS[owner] +=qtt  (commit.sid_dst -> commit.sid_src)
		
delete bid	stockS[owner]  -=qtt		stockA[owner] +=qtt

ob.tdraft_id_seq
*****************
it is the version number of the graph. Before the insertion of a set of
drafts, ob.tdraft_id_seq=N. At the time a set of n drafts is inserted, 
stocks are modified with version N, and when it is done, ob.tdraft_id_seq <- N+n.

*/
drop schema if exists public cascade;
create schema ob;
comment on schema ob is 
'Internal state of market';
create schema market;
comment on schema market is
'Public repesentation of market';
set search_path = ob;


create sequence ob.tdraft_id_seq; 
select setval('ob.tdraft_id_seq',1);

--------------------------------------------------------------------------------
-- FUNCTIONS USED BY TRIGGERS
--------------------------------------------------------------------------------
CREATE FUNCTION ob.ftime_created() 
	RETURNS trigger AS $$
BEGIN
	NEW.created := statement_timestamp();
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- ob.ftime_updated 
--	trigger before insert on ob.tquality, ob.towner, ob.tomega, ob.tstock
--------------------------------------------------------------------------------
CREATE FUNCTION ob.ftime_updated() 
	RETURNS trigger AS $$
BEGIN
	IF (TG_OP = 'INSERT') THEN
		NEW.created := statement_timestamp();
	ELSE 
		NEW.updated := statement_timestamp();
	END IF;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- ob.ins_version
--------------------------------------------------------------------------------
CREATE FUNCTION ob.ins_version() 
	RETURNS trigger AS $$
BEGIN
	SELECT last_value INTO NEW.version from ob.tdraft_id_seq;
	RETURN NEW;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- ob.tdraft
--------------------------------------------------------------------------------
CREATE FUNCTION ob.fcurrval_tdraft() 
	RETURNS int8 AS $$
DECLARE
	res	int8;
BEGIN
	SELECT last_value INTO res from ob.tdraft_id_seq;
	RETURN res;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;


/* functions of sslinfo */
CREATE FUNCTION ob.ssl_client_serial() RETURNS numeric
AS '$libdir/sslinfo', 'ssl_client_serial'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_is_used() RETURNS boolean
AS '$libdir/sslinfo', 'ssl_is_used'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_client_cert_present() RETURNS boolean
AS '$libdir/sslinfo', 'ssl_client_cert_present'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_client_dn_field(text) RETURNS text
AS '$libdir/sslinfo', 'ssl_client_dn_field'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_issuer_field(text) RETURNS text
AS '$libdir/sslinfo', 'ssl_issuer_field'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_client_dn() RETURNS text
AS '$libdir/sslinfo', 'ssl_client_dn'
LANGUAGE C STRICT;

CREATE FUNCTION ob.ssl_issuer_dn() RETURNS text
AS '$libdir/sslinfo', 'ssl_issuer_dn'
LANGUAGE C STRICT;

/*******************************************/
-- TABLES
/*******************************************/
--------------------------------------------------------------------------------
-- OB_TQUALITY
--------------------------------------------------------------------------------
-- create sequence ob.tquality_id_seq;
create table ob.tquality (
    id bigserial UNIQUE not NULL,
    name text,
    own name not NULL, 
    qtt bigint default 0,
    created timestamp,
    updated timestamp,
    PRIMARY KEY (id),
    UNIQUE(name,own)
);
alter sequence ob.tquality_id_seq owned by ob.tquality.id;
create index tquality_name_idx on ob.tquality(name);
create index tquality_own_idx on ob.tquality(own);
CREATE TRIGGER trig_befa_tquality BEFORE INSERT 
	OR UPDATE ON ob.tquality FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_updated();
	
--------------------------------------------------------------------------------
-- OB_TOWNER
--------------------------------------------------------------------------------
-- create sequence ob.towner_id_seq;
create table ob.towner (
    -- id int8 UNIQUE not NULL default nextval('ob.towner_id_seq'),
    id bigserial UNIQUE not NULL,
    name text,
    created timestamp,
    updated timestamp,
    PRIMARY KEY (id),
    UNIQUE(name)
);
alter sequence ob.towner_id_seq owned by ob.towner.id;
create index towner_name_idx on ob.towner(name);
CREATE TRIGGER trig_befa_towner BEFORE INSERT 
	OR UPDATE ON ob.towner FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_updated();
insert into ob.towner (name) values ('market');

--------------------------------------------------------------------------------
-- OB_TSTOCK
-- stores a value owned.

--------------------------------------------------------------------------------
-- create sequence ob.tstock_id_seq;
create table ob.tstock (
    id bigserial UNIQUE not NULL,
    own int8 references ob.towner(id) on update cascade 
	on delete restrict not NULL,
		-- owner can be deleted only if he has not stock
    qtt bigint not null, -- 64 bits
    nf int8 references ob.tquality(id) on update cascade 
	on delete restrict not NULL,
    version int8, 
    type char,
    	-- A account
    	-- S stock
    	-- D draft
    created timestamp,
    updated timestamp,
    PRIMARY KEY (id),
    CHECK (type in('A','S','D')),
    CHECK ( (type='A' and (own=1) and (qtt < 0 or qtt = 0)) 
    	-- market has only stock.qtt <=0
    	or (type='A' and (own!=1) and (qtt > 0 or qtt = 0))
    	-- owners have only stock.qtt >=0
    	or ((type='S' or type='D') and (qtt > 0 or qtt = 0)))
);
alter sequence ob.tstock_id_seq owned by ob.tstock.id;
create index tstock_own_idx on ob.tstock(own);
create index tstock_nf_idx on ob.tstock(nf,type);

CREATE TRIGGER trig_befa_tstock BEFORE INSERT 
	OR UPDATE ON ob.tstock  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_updated(); 

CREATE TRIGGER trig_befb_tstock BEFORE INSERT 
	OR UPDATE ON ob.tstock FOR EACH ROW 
	EXECUTE PROCEDURE ob.ins_version();
	
--------------------------------------------------------------------------------
-- OB_TNOEUD
--------------------------------------------------------------------------------
-- create sequence ob.tnoeud_id_seq;
create table ob.tnoeud ( -- bid
    id bigserial UNIQUE not NULL,
    sid int8 references ob.tstock(id) on update cascade 
	on delete cascade not NULL , -- refers to a stock
    omega double precision check(omega > 0),
    nr int8 references ob.tquality(id) on update cascade 
	on delete cascade not NULL ,
    nf int8 references ob.tquality(id) on update cascade 
	on delete cascade not NULL ,
    own int8 references ob.towner(id) on update cascade 
	on delete cascade not NULL ,
    provided_quantity int8,
    required_quantity int8, 
	-- omega = provided_quantity/required_quantity
    created timestamp,
    PRIMARY KEY (id)
);
alter sequence ob.tnoeud_id_seq owned by ob.tnoeud.id;
create index tnoeud_sid_idx on ob.tnoeud(sid);
create index tnoeud_nr_idx on ob.tnoeud(nr);
create index tnoeud_nf_idx on ob.tnoeud(nf);
create index tnoeud_own_idx on ob.tnoeud(own);

CREATE TRIGGER trig_befa_tnoeud BEFORE 
	INSERT ON ob.tnoeud  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_created(); 
	
--------------------------------------------------------------------------------
-- OB_TDRAFT
-- draft		status
-- created		D<-
-- accepted		A<-D	all commit are accepted
-- refused		R<-D	one (or more) commit is refused
--------------------------------------------------------------------------------
create table ob.tdraft (
    id int8 UNIQUE not NULL, -- never 0, but 1..n for n drafts
    status char,
	--  DRAFT=D, ACCEPTED=A, CANCELLED=C, 
    versionsg int8, 
	-- version of the subgraph that produced it
    version_decision int8 default NULL,
    nbsource int2,
    nbnoeud int2,
    cflags int4,
    delay int8, 
    created timestamp,
     CHECK (status in('A','C','D')),
     CHECK ((nbnoeud <= 8) and (nbnoeud >=2)),
    PRIMARY KEY(id)
);
-- alter sequence ob.tdraft_id_seq owned by ob.tdraft.id;
CREATE TRIGGER trig_befa_tdraft BEFORE INSERT 
	ON ob.tdraft  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_created(); 

--------------------------------------------------------------------------------
-- OB_TCOMMIT
--------------------------------------------------------------------------------
-- create sequence ob.tcommit_id_seq;
create table ob.tcommit (
	--id int8 UNIQUE not NULL default nextval('ob.tcommit_id_seq'),
	id bigserial UNIQUE not NULL,
	did int8 references ob.tdraft(id) 
		on update cascade on delete cascade,
	bid int8 references ob.tnoeud(id) 
		on update cascade,
	sid_src int8 references ob.tstock(id) 
		on update cascade,
	sid_dst int8 references ob.tstock(id) 
		on update cascade,
	--qid	int8 references ob.tquality(id) on update cascade,
	wid	int8 references ob.towner(id) 
		on update cascade,
	flags int4, 	-- [0] draft did accepted by owner wid,
			-- [1] draft did refused by owner wid,
			-- [2] exhausted: stock.qtt=fluxarrondi for sid
	PRIMARY KEY(id)
);
alter sequence ob.tcommit_id_seq owned by ob.tcommit.id;
create index tcommit_did_idx on ob.tcommit(did);
create index tcommit_sid_src_idx on ob.tcommit(sid_src);
create index tcommit_sid_dst_idx on ob.tcommit(sid_dst);


--------------------------------------------------------------------------------
-- OB_TOMEGA
--------------------------------------------------------------------------------
create table ob.tomega (
	scale integer, 
	-- scale=2, omega= "234.23"
	-- scale=NULL omega= "0.23423E03"
	nr int8 references ob.tquality(id) 
		on update cascade on delete cascade not null,
	nf int8 references ob.tquality(id) 
		on update cascade on delete cascade not null,
	name	text,
	created timestamp,
	updated timestamp,
	PRIMARY KEY(nr,nf) 
);
create index tomega_name_idx on ob.tomega(name);

CREATE TRIGGER trig_befa_tomega BEFORE INSERT 
	OR UPDATE ON ob.tomega  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_updated(); 
	
--------------------------------------------------------------------------------
-- OB_TLOMEGA
--------------------------------------------------------------------------------
create table ob.tlomega ( -- prices
	qttr bigint check (qttr >=0) not null,
	qttf bigint check (qttf >=0) not null,
	nr int8 references ob.tquality(id) 
		on update cascade on delete cascade not null,
	nf int8 references ob.tquality(id) 
		on update cascade on delete cascade not null,
	flags int4,	
		/* 
		[0] when the read_omega(dnr,dnf) 
			that inserted it was such as (dnr,dnf)=(nr,nf)
		[1] when inserted while a bid is inserted */
	created timestamp
);
create index tlomega_nr_idx on ob.tlomega(nr);
create index tlomega_nf_idx on ob.tlomega(nf);
CREATE TRIGGER trig_befa_tlomega BEFORE 
	INSERT ON ob.tlomega  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_created(); 
--------------------------------------------------------------------------------
-- OB_TMVT
--	An owner can be deleted only if he owns no stocks.
--	When it is deleted, it's movements are deleted
--------------------------------------------------------------------------------
-- create sequence ob.tmvt_id_seq;
create table ob.tmvt (
    	--id int8 UNIQUE not NULL default nextval('ob.tmvt_id_seq'),
        id bigserial UNIQUE not NULL,
    	did int8 references ob.tmvt(id) 
		on delete cascade default NULL, 
    	-- References the first mvt of a draft.
		-- NULL when movement add_account()
		-- not NULL for a draft executed. 
	own_src int8 references ob.towner(id) 
		on update cascade on delete cascade not null, 
	own_dst int8  references ob.towner(id) 
		on update cascade on delete cascade not null,
	qtt bigint check (qtt >0 or qtt = 0) not null,
	nat int8 references ob.tquality(id) 
		on update cascade on delete cascade not null,
	created timestamp
);
create index tmvt_did_idx on ob.tmvt(did);
-- create index tmvt_src_idx on ob.tmvt(src);
-- create index tmvt_dst_idx on ob.tmvt(dst);
create index tmvt_nat_idx on ob.tmvt(nat);
create index tmvt_own_src_idx on ob.tmvt(own_src);
create index tmvt_own_dst_idx on ob.tmvt(own_dst);
-- create index tmvt_nat_idx on ob.tmvt(nat);

CREATE TRIGGER trig_befa_tmvt BEFORE INSERT 
	ON ob.tmvt  FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_created();
	
--------------------------------------------------------------------------------  
create type ob.tlmvt AS (
        id int8,
    	did int8,  
	src int8,
	own_src int8, 
	dst int8,
	own_dst int8,
	qtt bigint,
	nat int8
);

--------------------------------------------------------------------------------
 -- OB_TCONNECTDESC
--------------------------------------------------------------------------------
create table ob.tconnectdesc (
    conninfo text UNIQUE,
    conn_datas int8[], -- list of 8 int8 expressed in microseconds
    valid		bool,
    PRIMARY KEY (conninfo)
);
INSERT INTO ob.tconnectdesc (conninfo,valid) 
	VALUES ('dbname = ob user=olivier',true);

--------------------------------------------------------------------------------
 -- 
--------------------------------------------------------------------------------
/*GRANT SELECT ON TABLE 
	ob.tconnectdesc,ob.tquality,ob.towner,ob.tstock,
	ob.tnoeud,ob.tdraft,
	ob.tcommit,ob.tomega,ob.tlomega,ob.tmvt 
	TO depositary;	*/
/*******************************************/
 -- VIEWS
/*******************************************/
--------------------------------------------------------------------------------
-- market.vowned
--------------------------------------------------------------------------------
/* List of values owned by users GROUP BY s.own,s.nf,q.name,o.name,q.own 
	view
		returns qtt owned for each (quality,own).
			qown		quality.own
			qname:		quality.name
			owner: 		owner.name
			qtt:		sum(qtt) for this (quality,own)
			created:	min(created)
			updated:	max(updated?updated:created)
	usage:
		SELECT * FROM market.vowned WHERE owner='toto'
			total values owned by the owner 'toto'
		SELECT * FROM market.vowned WHERE qown='banquedefrance'
			total values of owners whose qualities are owned by the depositary 'banquedefrance'
*/
--------------------------------------------------------------------------------
CREATE VIEW market.vowned AS SELECT 
		q.own as qown,
		q.name as qname,
		o.name as owner,
		sum(s.qtt) as qtt,
		min(s.created) as created,
		max(CASE WHEN s.updated IS NULL 
			THEN s.created ELSE s.updated END) 
			as updated
    	FROM ob.tstock s 
		INNER JOIN ob.towner o ON (s.own=o.id) 
		INNER JOIN ob.tquality q on (s.nf=q.id) 
	GROUP BY s.own,s.nf,q.name,o.name,q.own;
	
GRANT SELECT ON TABLE market.vowned TO depositary;

--------------------------------------------------------------------------------
-- market.vbalance 
--------------------------------------------------------------------------------
-- PUBLIC
/* List of values owned by users GROUP BY q.name,q.own
view
	returns sum(qtt)  for each quality.
			qown:		quality.own
			qname:		quality.name
			qtt:		sum(qtt) for this (quality)
			created:	min(created)
			updated:	max(updated?updated:created)
	usage:
	
		SELECT * FROM market.vbalance WHERE qown='banquedefrance'
			total values owned by the depositary 'banquedefrance'
			
		SELECT * FROM market.vbalance WHERE qtt != 0 and qown='banquedefrance'
			Is empty if accounting is correct for the depositary
*/
--------------------------------------------------------------------------------
CREATE VIEW market.vbalance AS SELECT 
		q.own as qown,
    		q.name as qname,
		sum(s.qtt) as qtt,
    		min(s.created) as created,
    		max(CASE WHEN s.updated IS NULL 
			THEN s.created ELSE s.updated END)  
			as updated
    	FROM ob.tstock s INNER JOIN ob.tquality q on (s.nf=q.id)
	GROUP BY q.name,q.own;
	
GRANT SELECT ON TABLE market.vbalance TO depositary,market;

--------------------------------------------------------------------------------
-- market.vdraft
--------------------------------------------------------------------------------
-- PUBLIC
/* List of draft by owner
view
		returns a list of drafts where the owner is partner.
			did		draft.id		
			status		'D','A' or 'C'
			owner		owner providing the value
			cntcommit	number of commits
			flags		[0] set when accepted by owner
					[1] set when refuse by owner
			created:	timestamp
	usage:
		SELECT * FROM market.vdraft WHERE owner='toto'
			list of drafts for the owner 'toto'
*/
--------------------------------------------------------------------------------
CREATE VIEW market.vdraft AS 
		SELECT 	
			dr.id as did,
			dr.status as status,
			w.name as owner,
			co.cnt as cntcommit,
			co.flags as flags,
			dr.created as created
		FROM (
			SELECT c.did,c.wid,(bit_or(c.flags)&2)|(bit_and(c.flags)&1) as flags,count(*) as cnt 
			FROM ob.tcommit c GROUP BY c.wid,c.did 
				) AS co 
		INNER JOIN ob.tdraft dr ON co.did = dr.id
		INNER JOIN ob.towner w ON w.id = co.wid;
	
GRANT SELECT ON TABLE market.vdraft TO depositary;

--------------------------------------------------------------------------------
-- market.vbid
--------------------------------------------------------------------------------
-- PUBLIC
/* List of bids
view
		returns a list of bids.
			id			noeud.id		
			owner			w.owner
			required_quality
			required quantity
			omega
			provided quality
			provided_quantity
			sid
			qtt
			created	
	usage:
		SELECT * FROM market.vbid WHERE owner='toto'
			list of bids of the owner 'toto'
*/
--------------------------------------------------------------------------------
CREATE VIEW market.vbid AS 
	SELECT 	
		n.id as id,
		w.name as owner,
		qr.name as required_quality,
		n.required_quantity as required_quantity,
		CAST(n.provided_quantity as double precision)/CAST(n.required_quantity as double precision) as omega,
		qf.name as provided_quality,
		n.provided_quantity as provided_quantity,
		s.id as sid,
		s.qtt as qtt,
		n.created as created
	FROM ob.tnoeud n
	INNER JOIN ob.tquality qr ON n.nr = qr.id 
	INNER JOIN ob.tstock s ON n.sid = s.id
	INNER JOIN ob.tquality qf ON s.nf =qf.id
	INNER JOIN ob.towner w on s.own = w.id
	ORDER BY n.created DESC;
	
GRANT SELECT ON TABLE market.vbid TO depositary;

--------------------------------------------------------------------------------
-- market.vmvt R
--------------------------------------------------------------------------------
-- view PUBLIC
/* 
		returns a list of movements related to the owner.
			id		ob.tmvt.id
			did:		NULL for a movement made by market.fadd_account()
					not NULL for a draft executed, even if it has been deleted.
			provider
			nat:		quality.name moved
			qtt:		quantity moved, 
			receiver
			created:	timestamp

*/
--------------------------------------------------------------------------------
CREATE VIEW market.vmvt AS 
	SELECT 	m.id as id,
		m.did as did,
		w_src.name as provider,
		q.name as nat,
		m.qtt as qtt,
		w_dst.name as receiver,
		m.created as created
	FROM ob.tmvt m
	INNER JOIN ob.towner w_src ON (m.own_src=w_src.id)
	INNER JOIN ob.towner w_dst ON (m.own_dst=w_dst.id) 
	INNER JOIN ob.tquality q ON (m.nat = q.id);
	
GRANT SELECT ON TABLE market.vmvt TO depositary;

/*
--------------------------------------------------------------------------------
T	ob.ftime_created
T	ob.ftime_updated
T	ob.ins_version
	ob.fcurrval_tdraft

views
	market.vowned
	market.vbalance
	market.vdraft
	market.vbid
	market.vmvt

functions
P	market.fcreate_quality
P	market.fstats *
P	market.fadd_account
P	market.fsub_account
P	market.finsert_sbid
P	market.finsert_bid
P	market.faccept_draft	
P	market.frefuse_draft
P	market.fdelete_bid
P	market.fbatch_omega *

	ob.getdraft_get
	ob.fupdate_status_commits
	ob.fread_status_draft
	ob.fexecute_commit
	ob.fexecute_draft
	ob.finsert_omegap
	ob.finsert_omega_int
	ob.fomega_draft
	ob.finsert_omega
	ob.fremove_das
	ob.finsert_das
	market.fdelete_bid_int
	ob.fdelete_draft
	ob.frefuse_draft_int
	ob.finsert_bid_int
	ob.fread_omega
--------------------------------------------------------------------------------
		Calling tree

market.fbatch_omega
	ob.fread_omega
		ob.finsert_omega
			ob.finsert_omega_int
		market.fdelete_bid_int	
			ob.frefuse_draft_int
				ob.fread_status_draft
				ob.fupdate_status_commits
			ob.fremove_das

market.finsert_sbid
	ob.finsert_bid_int
		ob.getdraft_get *
		ob.finsert_das
		ob.fomega_draft
		
market.finsert_bid
	ob.finsert_das
	ob.finsert_bid_int
		ob.getdraft_get *
		ob.finsert_das
		ob.fomega_draft

market.faccept_draft
	ob.fread_status_draft
	ob.fupdate_status_commits
	ob.fexecute_draft
		ob.fexecute_commit
		
market.frefuse_draft
	ob.fread_status_draft
	ob.fupdate_status_commits

ob.fexecute_draft
	ob.fexecute_commit

market.fstats
	ob.fread_status_draft

 the name of a depositary is a user name.
the role rdepositary has read access on ob.tmvt,ob.tstock
and can execute market.fadd_account

error codes are 'OBxxxx' 
************************
-30401	no candidate ob.fread_omega(nr,nf)
-30402	the quality.id was not found
-30403	the bid.id was not found
-30404	the account  was not found or not big enough or it's quality not owned by user
-30405	the quality.name was not found
-30406	omega should be >=0
-30407	the pivot was not found
-30408	the stock is not big ebough
-30409	the stock.id is not found
-30410	commit.id sequence is not 0..N
-30411		the draft is outdated
-30412	the owner.name is not found
-30413	The quality does not exist or is not owned by user
-30414	the qtt sould be >0
-30415	qttprovided is <=0
-30416	No stock of this draft is both owned by owner and of a quality owned by user
-30417	The owner is not partner of the Draft
-30418	Less than 2 commit found for the draft
-30419	The draft status is corrupted
-30420	the draft.id was not found
-30421	The owner.name does not exist
-30422	The draft has a status that does not allow the transition to this status
-30423	Abort in bid removal	(unused)
-30424	The stock of a quality owned by user is not found
-30425	the stock sid_dst was not found for the draft
-30426	the stock has the wrong type
-30427	the stock could not be inserted
-30428	The draft % has less than two commits
-30429	for commit % the stock % was not found
-30430	the type of the stock should be S or D and qtt > 0
-30431	The draft % has less than two commits
-30432	The quality % already exists for market
-30433	The quality % overflows
-30434	The quality % underflows
-30435	Cannot delete the draft
-30436	Cannot delete the draft
-30437	StockD % for the draft % not found
-30438  Internal Error
-30439	Client certificate required

-30100 to -30299 internal error
	-30144 loopOnOffer
-30800 to -30999 BerkeleyDb error
-30400 to -30499 psql error

*/
--------------------------------------------------------------------------------
-- PUBLIC FUNCTIONS
--------------------------------------------------------------------------------

/* 
market.fstats and market.fbatch_omega are granted to market

ret int = market.fcreate_quality(_name text)
market.fstats() RETURNS SETOF market.tret_stats

ret int = market.fadd_account(owner text,quality text,_qtt int8)
ret int = market.fsub_account(owner text,quality text,_qtt int8)

ret int = market.finsert_sbid(bid_id int8,_qttrequired int8,_qualityrequired text)
ret int = market.finsert_bid(_owner text,_qualityprovided text,_qttprovided int8,_qttrequired int8,_qualityrequired text)

ret int = market.faccept_draft(draft_id int8,owner text)
ret int = market.frefuse_draft(draft_id int8,owner text)

err int = market.fdelete_bid(bid_id int8)
ret int  = market.fbatch_omega()

-- 
*/
/*******************************************/
 -- PUBLIC FUNCTIONS
/*******************************************/
--------------------------------------------------------------------------------
-- PUBLIC
/* 	returns 0 or 
		[-30432] The quality already exists
*/
--------------------------------------------------------------------------------
CREATE FUNCTION market.fcreate_quality(_name text) 
	RETURNS int AS $$
DECLARE 
	_q 	ob.tquality%rowtype;
	_n	text;
	_user	text;
BEGIN
	_user = ob.fgetuser(1);
	_n := _user || '>' || _name;
	SELECT q.* INTO _q FROM ob.tquality q WHERE q.name=_n and q.own=_user LIMIT 1;
	IF NOT FOUND THEN
		INSERT INTO ob.tquality(name,own,qtt) 
			VALUES (_n,_user,0) RETURNING * INTO _q;
	ELSE
		RAISE NOTICE '[-30432] The quality % already exists',_n;
		RETURN -30432;
	END IF;
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- market.fstats
--------------------------------------------------------------------------------
-- PUBLIC
/* usage:
	ret market.fstats = market.fstats()


	returns a list of market.tret_stats
*/
--------------------------------------------------------------------------------
-- DROP TYPE IF EXISTS market.tret_stats CASCADE;
CREATE TYPE market.tret_stats AS (

	mean_time_drafts int8, -- mean of delay for every drafts
	
	nb_drafts		int8,
	nb_noeuds		int8,
	nb_stocks		int8,
	nb_stocks_s	int8,
	nb_stocks_d	int8,
	nb_stocks_a	int8,
	nb_qualities 	int8,
	nb_owners		int8,
	
	-- followings should be all 0
	unbananced_qualities 	int8,
	corrupted_draft		int8,
	corrupted_stock_s	int8,
	corrupted_stock_a	int8,
	
	created timestamp
);
--------------------------------------------------------------------------------
CREATE FUNCTION market.fstats() RETURNS market.tret_stats AS $$
DECLARE
	ret market.tret_stats%rowtype;
	delays int8;
	cnt int8;
	err int8;
	_draft ob.tdraft%rowtype;
	res int;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	ret.created := statement_timestamp();
	
	-- mean time of draft
	SELECT SUM(delay),count(*) INTO delays,cnt FROM ob.tdraft;
	ret.nb_drafts := cnt;
	ret.mean_time_drafts = CAST( delays/cnt AS INT8);
	
	SELECT count(*) INTO cnt FROM ob.tnoeud;
	ret.nb_noeuds := cnt;
	SELECT count(*) INTO cnt FROM ob.tstock;
	ret.nb_stocks := cnt;
	SELECT count(*) INTO cnt FROM ob.tstock WHERE type='A';
	ret.nb_stocks_a := cnt;
	SELECT count(*) INTO cnt FROM ob.tstock WHERE type='D';
	ret.nb_stocks_d := cnt;
	SELECT count(*) INTO cnt FROM ob.tstock WHERE type='S';
	ret.nb_stocks_s := cnt;
	SELECT count(*) INTO cnt FROM ob.tquality;
	ret.nb_qualities := cnt;
	SELECT count(*) INTO cnt FROM ob.towner;
	ret.nb_owners := cnt;	

	-- number of unbalanced qualities 
	-- for a given quality, we should have:
	-- 	sum(stock_A.qtt)+sum(stock_S.qtt)+sum(stock_D.qtt) = quality.qtt 
	SELECT count(*) INTO cnt FROM (
		SELECT sum(abs(s.qtt)) 
		FROM ob.tstock s,ob.tquality q WHERE s.nf=q.id
		GROUP BY s.nf,q.qtt having (sum(abs(s.qtt))!= q.qtt)
	) as q;
	ret.unbananced_qualities := cnt;
	
	-- number of draft corrupted
	ret.corrupted_draft := 0;
	ret.nb_drafts := 0;
	FOR _draft IN SELECT * FROM ob.tdraft LOOP
		res := ob.fread_status_draft(_draft);
		IF(res < 0) THEN 
			ret.corrupted_draft := ret.corrupted_draft +1;
		ELSE  
			ret.nb_drafts := ret.nb_drafts +1;
		END IF;
	END LOOP;
	
	-- stock corrupted
	-- stock_s unrelated to a bid should not exist 
	SELECT count(s.id) INTO err FROM ob.tstock s 
		LEFT JOIN ob.tnoeud n ON n.sid=s.id
	WHERE s.type='S' AND n.id is NULL;
	ret.corrupted_stock_s := err;
	-- Stock_A not unique
	SELECT count(*) INTO err FROM(
		SELECT count(s.id) FROM ob.tstock s 
		WHERE s.type='A'
		GROUP BY s.nf,s.own HAVING count(s.id)>1) as c;
	ret.corrupted_stock_a := err;
	RETURN ret;
END; 
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- market.fadd_account 
-- PUBLIC
/* usage:
	ret int = market.fadd_account(owner text,quality text,_qtt int8)
	
	conditions:
		quality  exist,
		_qtt >=0
		
	actions:
		owner is created if it does not exist
		moves qtt from 	market_account[nat]		->	owners_account[own,nat]
		accounts are created when they do not exist
		the movement is recorded.
			
	returns 0 when done correctly
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.fadd_account(_owner text,_quality text,_qtt int8) 
	RETURNS int AS $$
DECLARE
	_wid int8;
	_nf int8;
	_qtt_quality int8;
	_new_qtt_quality int8;
	mvt ob.tmvt%rowtype;
	acc ob.tstock%rowtype;
	err	int :=0;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	SELECT id,qtt INTO _nf,_qtt_quality FROM ob.tquality 
		WHERE name =  _quality AND own = _user;
	IF NOT FOUND THEN 
		err := -30405;
		RAISE EXCEPTION '[-30405]The quality % does not exist or is not yours',_quality   USING ERRCODE='38000';
	END IF;
	IF (_qtt <= 0) THEN
		err := -30414;
		RAISE EXCEPTION '[-30414] the quantity cannot be negative or null'   USING ERRCODE='38000';
	END IF;
	-- TODO What ?????
	BEGIN
		INSERT INTO ob.towner (name) VALUES ( _owner) 
			RETURNING id INTO _wid;
	EXCEPTION WHEN unique_violation THEN 
	END;
	SELECT id INTO _wid from ob.towner WHERE name=_owner;

	UPDATE ob.tquality SET qtt = qtt + _qtt 
		WHERE id= _nf RETURNING qtt INTO _new_qtt_quality;
	IF (_qtt_quality >= _new_qtt_quality ) THEN 
		err := -30433;
		RAISE EXCEPTION '[-30433] Quality % owerflows',_quality   USING ERRCODE='38000';
	END IF;
	
	-- foreign keys of quality and owner protects form insertion of unknown keys
	UPDATE ob.tstock SET qtt = qtt+_qtt  
		WHERE own=_wid AND nf=_nf AND type='A' 
		RETURNING * INTO acc;
	IF NOT FOUND THEN
		INSERT INTO ob.tstock (own,qtt,nf,type) 
		VALUES (_wid,_qtt,_nf,'A') 
		RETURNING * INTO acc;
	END IF;
	INSERT INTO ob.tmvt (own_src,own_dst,qtt,nat) 
		VALUES (1,acc.own, _qtt,acc.nf) 
		RETURNING * INTO mvt;
	RETURN 0;
END; 
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
	
--------------------------------------------------------------------------------
-- market.fsub_account R
-- PUBLIC
/* usage:
	ret int = market.fsub_account(_owner text,_quality text,_qtt int8)
	
	conditions:
		owner and quality  exist,
		_qtt >=0
		
	actions:
		moves qtt from 	
			market_account[nat]	<-owners_account[own,nat]
		account are deleted when empty
		the movement is recorded.
			
	returns 0 when done correctly
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.fsub_account(_owner text,_quality text,_qtt int8) 
	RETURNS int AS $$
DECLARE
	_wid int8;
	_nf int8;
	_qtt_quality int8;
	acc ob.tstock%rowtype;
	mar ob.tstock%rowtype;
	mvt ob.tmvt%rowtype;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	SELECT id INTO _wid FROM ob.towner 
		WHERE name=_owner;
	IF (NOT FOUND) THEN 
		RAISE EXCEPTION '[-30412] The owner % does not exist',owner;
	END IF;

	SELECT id INTO _nf FROM ob.tquality 
		WHERE name= _quality AND own=_user;
	IF (NOT FOUND) THEN 
		RAISE EXCEPTION '[-30413] The quality % does not exist or is not deposited by user',_quality   USING ERRCODE='38000';
	END IF;
	IF (_qtt <= 0) THEN
		RAISE EXCEPTION '[-30414] the quantity cannot be negative or null'  USING ERRCODE='38000';
	END IF;

	-- foreign keys of quality and owner protects form insertion of unknown keys
	SELECT s.* INTO acc FROM ob.tstock s 
		WHERE s.own=_wid AND s.nf=_nf AND s.type='A' 
		LIMIT 1;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30404] the account is empty'  USING ERRCODE='38000';
	END IF;

	UPDATE ob.tstock SET qtt = qtt-_qtt 
		WHERE id = acc.id RETURNING * INTO acc;
	IF(acc.qtt < 0) THEN
		RAISE EXCEPTION '[-30404] the account is not big enough'  USING ERRCODE='38000';	
	END IF;	
		
	UPDATE ob.tquality SET qtt = qtt - _qtt 
		WHERE id=acc.nf RETURNING qtt INTO _qtt_quality;
	IF (_qtt_quality < 0) THEN
		RAISE EXCEPTION '[-30434] the quality % underflows ',_quality  USING ERRCODE='38000';
	END IF;	
	
	INSERT INTO ob.tmvt (own_src,own_dst,qtt,nat) 
		VALUES (acc.own,1,_qtt,acc.nf) RETURNING * 
		INTO mvt;

	IF(acc.qtt = 0) THEN 
		DELETE FROM ob.tstock WHERE id=acc.id;
	END IF;

	RETURN 0;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
	
--------------------------------------------------------------------------------
-- market.finsert_sbid
--------------------------------------------------------------------------------
-- PUBLIC
/* usage: 
	nb_draft int8 = market.finsert_sbid(bid_id int8,_qttprovided int8,_qttrequired int8,_qualityrequired text)
	
	conditions:
		noeud.id=bid_id exists
		the pivot noeud.sid exists.
		_omega > 0
		_qualityrequired text
		
	action:
		inserts a bid with the same stock as bid_id. 
	
	returns nb_draft:
		the number of draft inserted.
		-30403, the bid_id was not found
		-30404, the quality of stock offered is not owned by user 
		or error returned by ob.finsert_bid_int
*/
--------------------------------------------------------------------------------		
CREATE FUNCTION 
	market.finsert_sbid(bid_id int8,_qttprovided int8,_qttrequired int8,_qualityrequired text) 
	RETURNS int AS $$
DECLARE
	noeud	ob.tnoeud%rowtype;
	cnt 		int;
	stock 	ob.tstock%rowtype;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	cnt := ob.fbidallowed(_user);
	SELECT n.* INTO noeud FROM ob.tnoeud n 
		WHERE n.id = bid_id;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30403] the bid % was not found',bid_id USING ERRCODE='38000';
	END IF;
	-- controls
	SELECT s.* INTO stock FROM ob.tstock s 
		WHERE  s.id = noeud.sid ;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30404] the stock % was not found',noeud.sid USING ERRCODE='38000';
	END IF;
	
	cnt := ob.finsert_bid_int(noeud.sid,_qttrequired,_qttprovided,_qualityrequired);
	if cnt <0 THEN 
		RAISE EXCEPTION '[%] in ob.finsert_bid_int',cnt USING ERRCODE='38000';
	END IF;
	RETURN cnt;
END; 
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
	
--------------------------------------------------------------------------------
-- market.finsert_bid
--------------------------------------------------------------------------------
-- PUBLIC
/* usage: 
	nb_draft int8 = market.finsert_bid(_owner text,_qualityprovided text,qttprovided int8,_qttrequired int8,_qualityrequired text)

	conditions:
		stock.id=acc exists and stock.qtt >=qtt
		_omega != 0
		_qualityrequired exists
		
	action:
		inserts a stock and a bid.
	
	returns nb_draft:
		the number of draft inserted.
		nb_draft == -30404, the _acc was not big enough or it's quality not owner by the user
		or error returned by ob.finsert_bid_int

*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.finsert_bid(_owner text,_qualityprovided text,_qttprovided int8,_qttrequired int8,_qualityrequired text) 
	RETURNS int AS $$
	
DECLARE
	cnt int;
	i	int8;
	mvt ob.tlmvt%rowtype;
	stock ob.tstock%rowtype;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	cnt := ob.fbidallowed(_user);
	-- controls
	SELECT s.* INTO stock FROM ob.tstock s 
		INNER JOIN ob.towner w ON (w.id=s.own ) 
		INNER JOIN ob.tquality q ON ( s.nf=q.id )
		WHERE s.type='A' and (s.qtt >=_qttprovided) AND q.name=_qualityprovided and w.name=_owner;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30404] the account was not found or not big enough' USING ERRCODE='38000';
	END IF;
	
	-- stock with qtt=0 does not exist.
	mvt := ob.finsert_das(stock,_qttprovided,'S');
	-- RAISE INFO 'la % ',stock.id;
	IF(mvt.id <0) THEN 
		RAISE EXCEPTION '[%] in ob.finsert_das',mvt.id USING ERRCODE='38000';
	END IF;
	cnt := ob.finsert_bid_int(mvt.dst,_qttprovided,_qttrequired,_qualityrequired);
	if cnt <0 THEN 
		RAISE EXCEPTION '[%] in ob.finsert_bid_int',cnt USING ERRCODE='38000';
	END IF;
	RETURN cnt;
END; 
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- market.faccept_draft
--------------------------------------------------------------------------------
-- PUBLIC 
/* usage: 
	ret int = market.faccept_draft(draft_id int8,owner text)
		own_id
		draft_id
conditions:
	draft_id exists with status D

returns a char:
		0 the draft is not yet accepted, 
		1 the draft is executed, NON, retourne 0!
		< 0 error
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.faccept_draft(draft_id int8,owner text) 
	RETURNS int AS $$
DECLARE
	draft 		ob.tdraft%rowtype;
	_commot	ob.tcommit%rowtype;
	accepted	int4; -- 1 when accepted by others
	_nbcommit	int :=0;
	_nbpartner	int;
	ownfound	bool := false;
	d_status	char;
	res 		int;
	own_id		int8;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	SELECT d.* INTO draft FROM ob.tdraft d 
		WHERE d.id=draft_id;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30420] the draft % was not found',draft_id USING ERRCODE='38000';
	END IF;
	SELECT id INTO own_id FROM ob.towner 
		WHERE name=owner;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30421] The owner % does not exist',owner USING ERRCODE='38000';
	END IF;
	res := ob.fread_status_draft(draft);
	-- res=0 means it is a draft
	IF (res <0) THEN
		RAISE EXCEPTION '[%] in ob.fread_status_draft',res USING ERRCODE='38000';
	END IF;
	IF((NOT(draft.status = 'D')) OR res!=0 ) THEN 
		RAISE EXCEPTION '[-30422] The draft % has a status %, whith res=%',draft.id,draft.status,res USING ERRCODE='38000';
	END IF;	

	SELECT bit_and(flags&1),count(*) INTO accepted,_nbpartner 
		FROM ob.tcommit WHERE did = draft_id AND wid!=own_id;
	if(_nbpartner = 0) THEN -- only one partner for this draft
		accepted := 1; 
	END IF;
	-- accepted=1 when is it accepted by others
	
	------------- update status of commits ------------------------------	
	res := ob.fupdate_status_commits(draft_id,own_id,1,3);
	IF (res < 0 ) THEN -- the owner was not found, draft unmodified
		RAISE EXCEPTION '[%] in ob.fupdate_status_commits',res USING ERRCODE='38000';
	END IF;
	
	------------- execute -------------------------------------------------
	--    RAISE INFO 'accepted by others %',accepted;
	if(accepted = 1) THEN
		res := ob.fexecute_draft(draft_id);
		IF (res<0) THEN 
			RAISE EXCEPTION '[%] in ob.fexecute_draft',res USING ERRCODE='38000';
		END IF;
		-- the draft is now empty, it can be deleted
		res := ob.fdelete_draft(draft_id);
		IF (res<0) THEN 
			RAISE EXCEPTION '[%] in ob.fdelete_draft',res USING ERRCODE='38000';
		END IF;
	END IF;
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- market.frefuse_draft
--------------------------------------------------------------------------------
-- PUBLIC 
/* usage: 
	ret int = market.frefuse_draft(draft_id int8,owner text)
		own_id
		draft_id
	quantities are stored back into the stock S
	A ret is returned.
		1 the draft is cancelled
		<0 error

*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.frefuse_draft(draft_id int8,owner text) 
	RETURNS int AS $$
DECLARE
	own_id	int8;
	res	int;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	SELECT id INTO own_id FROM ob.towner 
		WHERE name = owner;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30421] The owner % does not exist',owner USING ERRCODE='38000';
	END IF;
	res := ob.frefuse_draft_int(draft_id,own_id);
	IF( res < 0 ) THEN
		RAISE EXCEPTION '[%] in ob.frefuse_draft_int',res USING ERRCODE='38000';
	END IF;
	RETURN res;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
	
--------------------------------------------------------------------------------
-- market.fdelete_bid
--------------------------------------------------------------------------------
-- PUBLIC 
/* usage: 
	err int = market.fdelete_bid(bid_id int8)
	
	delete bid and related drafts
	delete related stock if it is not related to an other bid
		(in this case, the stock is not referenced by any draft). The quantity of this stock is moved back to the account.
	
	A given stock is deleted by the market.fdelete_bid of the last bid it references.
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.fdelete_bid(bid_id int8) RETURNS int AS $$
DECLARE
	ret		int;
	_user text;
BEGIN
	_user := ob.fgetuser(1);
	ret := market.fdelete_bid_int(bid_id);
	IF(ret <0) THEN 
		RAISE EXCEPTION 'error % ' USING ERRCODE='38000'; 
	END IF;
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
	
--------------------------------------------------------------------------------
-- market.fbatch_omega
--------------------------------------------------------------------------------
-- PUBLIC 
/* usage: ret int  = market.fbatch_omega()

utility calling ob.fread_omega(nr,nf) for the couple (nr,nf) that needs refresh the most:
	-- a couple (nr,nf) such as ob.tomega[nr,nf] does not exist,
	-- if not found, oldest couple (cflags&1=0),
	-- if not found,  oldest couple such as (cflags&1=1)
	
Should be called by a cron.
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.fbatch_omega() 
	RETURNS int AS $$
DECLARE
	_nr	int8 :=0;
	_nf	int8 :=0;
	err 	int := 0;
	namef	text;
	namer	text;
	t	int8;
BEGIN

	START TRANSACTION;
	-- a couple (nr,nf) such as ob.tomega[nr,nf] does not exist,
	select pq.nr,pq.nf into _nr,_nf from (
			select q1.id as nr,q2.id as nf 
				from ob.tquality q1,ob.tquality q2 
				WHERE q1.id!=q2.id
			) as pq 
			left join ob.tomega o 
			on (o.nr=pq.nr and o.nf=pq.nf) 
			WHERE o.nr is null limit 1;
	IF NOT FOUND THEN 
		-- oldest couple (cflags&1=0), 
		-- if not found, oldest couple such as (cflags&1=1)
		-- select nr,nf into _nr,_nf from ob.tlomega 
		--	group by (flags&1=1),nr,nf order by (flags&1=1),max(created) asc limit 1;
		select nr,nf into _nr,_nf from ob.tomega 
			group by nr,nf order by max(
				CASE WHEN updated IS NULL 
				THEN created ELSE updated END
			)  asc limit 1;
		IF NOT FOUND THEN
			RAISE EXCEPTION '[-30401] no candidate ob.fread_omega(nr,nf)' USING ERRCODE='38000';
		END IF;
	END IF;
	
	err = ob.fread_omega(_nr,_nf);
	IF(err<0) THEN 
		IF (err = -30144) THEN
			RAISE LOG '[%] in ob.fread_omega',err;
		ELSE
			RAISE EXCEPTION '[%] in ob.fread_omega',err USING ERRCODE='38000'; 
		END IF;
	END IF;	
	RETURN err;
END; 
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
GRANT EXECUTE ON  FUNCTION market.fbatch_omega() TO admin;

/*******************************************/
 -- PRIVATE FUNCTIONS
/*******************************************/

create table ob.tldraft (
    id int8, 					--[0] 
	-- get_draft supposes that it is  >0 : 1,2,3 ... changes for each draft
    cix int2, -- between 0..nbnoeud-1	--[1] 
    nbsource int2,				--[2] 
    nbnoeud int2,				--[3] 
    cflags int4, -- draft flags		--[4] 
    bid int8, -- loop.rid.Xoid		--[5] 
    sid int8, -- loop.rid.Yoid		--[6] 
    wid int8, -- loop.rid.version		--[7] 
    fluxarrondi bigint,  			--[8] 
    flags int4, -- commit flags		--[9] 
    ret_algo int4,				--[10]
    versionsg int8
);

create function ob.getdraft_get(int8,double precision,int8,int8) 
	returns setof ob.tldraft
	as '$libdir/openbarter','ob_getdraft_get' 
	language C strict SECURITY DEFINER;

--------------------------------------------------------------------------------
-- ob.fupdate_status_commits
--------------------------------------------------------------------------------
-- PRIVATE called by market.faccept_draft() and market.frefuse_draft() to update flags of commits 
/* usage: 
	cnt_updated int = ob.fupdate_status_commits(draft_id int8,own_id int8,_flags int4,mask int4)
	
	updates flags of commits of a draft for a given owner with _flags and mask
	or error -30416,-30417; then, commits remain unchanged:
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.fupdate_status_commits(draft_id int8,own_id int8,_flags int4,mask int4) 
	RETURNS int AS $$
DECLARE 
	_commot ob.tcommit%rowtype;
	cnt		int := 0;
	own_name	text;
BEGIN
	SELECT count(c.id) INTO cnt FROM ob.tcommit c
		INNER JOIN ob.tstock s on (c.sid_src=s.id)
	 	INNER JOIN ob.tquality q ON (q.id=s.nf)
	WHERE c.did=draft_id AND q.own = user;
	IF cnt=0 THEN
		RAISE NOTICE '[-30416] No stock of the draft % is both owned by % and of a quality owned by user',draft_id,own_id;
		RETURN -30416;
	END IF; 
	cnt := 0;
	<<UPDATE_STATUS>>
	FOR _commot IN SELECT * FROM ob.tcommit 
		WHERE did = draft_id AND wid = own_id LOOP 
		UPDATE ob.tcommit 
		SET flags = (_flags & mask) |(flags & (~mask)) 
		WHERE  id = _commot.id;
		cnt := cnt +1;
	END LOOP UPDATE_STATUS;
	if(cnt =0) THEN 
		SELECT name INTO own_name FROM ob.towner 
		WHERE id=own_id;
		RAISE NOTICE '[-30417] The owner % is not partner of the Draft %',own_name,draft_id;
		RETURN -30417;
	END IF;
	RETURN cnt;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fread_status_draft
--------------------------------------------------------------------------------
-- PRIVATE  used by market.faccept_draft,market.frefuse_draft,market.fstats
/* usage: 
	ret int = ob.fread_status_draft(draft ob.tdraft)
	
conditions:
	draft_id exists
	the status of draft is normal
	
returns:
	2	Cancelled
	1	Accepted
	0	Draft
	-30418,-30419	error

*/
--------------------------------------------------------------------------------

CREATE 
	FUNCTION ob.fread_status_draft(draft ob.tdraft) 
	RETURNS int AS $$
DECLARE
	_commot	ob.tcommit%rowtype;
	cnt		int := 0;
	_andflags	int4 := ~0;
	_orflags	int4 := 0;
	expected	char;
BEGIN	-- 
	SELECT bit_and(flags),bit_or(flags),count(id) 
		INTO _andflags,_orflags,cnt FROM ob.tcommit 
		WHERE did = draft.id;
	IF(cnt <2) THEN
		RAISE NOTICE '[-30418] Less than 2 commit found for the draft %',draft.id;
		RETURN -30418;
	END IF;
	expected := 'D';
	IF(_orflags & 2 = 2) THEN -- one _commot.flags[1] set 
		expected := 'C';
	ELSE
		IF(_andflags & 1 = 1) THEN -- all _commot.flags[0] set
			expected :='A';
		END IF;
	END IF;
	IF(draft.status != expected) THEN
		RAISE NOTICE '[-30419] the status of the draft % should be % instead of %',draft.id,expected,draft.status;
		RETURN -30419;
	END IF;
	IF(draft.status = 'D') THEN
		RETURN 0;
	ELSIF (draft.status = 'A') THEN
		RETURN 1;
	ELSIF (draft.status = 'C') THEN
		RETURN 2;
	END IF;
	RAISE NOTICE '[-30419] the draft % has an illegal status %',draft.id,draft.status;
	RETURN -30419;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fexecute_commit
--------------------------------------------------------------------------------
-- PRIVATE used by ob.fexecute_draft()
/* usage: 
	mvt_id int8 = ob.fexecute_commit(commit_src ob.tcommit,commitsdt ob.tcommit)
		(commit_src,commit_dst) are two successive commits of a draft
		
condition:
	commit_src.sid_dst exists
actions:
	moves commit_src.sid_dst to account[commit_dst.wid,stock[commit_src.sid_dst].nf]
	records the movement
	removes the stock[commit_src.sid_dst]
	
returns:
	the id of the movement
*/
--------------------------------------------------------------------------------

CREATE FUNCTION 
	ob.fexecute_commit(commit_src ob.tcommit,commit_dst ob.tcommit) 
	RETURNS int8 AS $$
DECLARE
	m ob.tstock%rowtype;
	stock_src ob.tstock%rowtype;
	id_mvt int8;
	res int8;
BEGIN
	SELECT s.* INTO stock_src FROM ob.tstock s 
		WHERE s.id = commit_src.sid_dst and s.type='D';
	IF NOT FOUND THEN
		RAISE NOTICE '[-30429] for commit % the stock_src % was not found',commit_src.id,commit_src.sid_dst;  
		RETURN -30429;
	END IF;
	UPDATE ob.tstock SET qtt = qtt - stock_src.qtt 
		WHERE id = commit_src.sid_dst and type='D' 
		RETURNING qtt INTO res;
	IF NOT(res = 0) THEN
		RAISE NOTICE '[-30429] for commit % the stock_src % was not found',commit_src.id,commit_src.sid_dst;  
		RETURN -30429;
	END IF;	
	-- should become 0

	UPDATE ob.tstock SET qtt = qtt + stock_src.qtt 
		WHERE own = commit_dst.wid AND nf = stock_src.nf AND type = 'A'  
		RETURNING * INTO m;
	IF NOT FOUND THEN
		INSERT INTO ob.tstock (own,qtt,nf,type) 
			VALUES (commit_dst.wid,stock_src.qtt,stock_src.nf,'A') 
			RETURNING * INTO m; 
	END IF;
	INSERT INTO ob.tmvt (own_src,own_dst,qtt,nat) 
		VALUES (commit_src.wid,commit_dst.wid,stock_src.qtt,stock_src.nf) 
		RETURNING id INTO id_mvt;
	-- did is NOT set, it is at the end of the execute_draft to the first mvt_id for all commits of the draft	
	-- delete stock is useless since the draft is deleted just after execution, in market.faccept_draft() by ob.fdelete_draft()
	-- DELETE FROM ob.tstock WHERE id=stock_src.id;
	RETURN id_mvt;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fexecute_draft
--------------------------------------------------------------------------------
-- PRIVATE called by market.faccept_draft() when the draft should be executed 
/* usage: 
	cnt_commit integer = ob.fexecute_draft(draft_id int8)
action:
	execute ob.fexecute_commit(commit_src,commit_dst) for successive commits
*/
--------------------------------------------------------------------------------
CREATE 
	FUNCTION ob.fexecute_draft(draft_id int8) 
	RETURNS int AS $$
DECLARE
	prev_commit	ob.tcommit%rowtype;
	first_commit	ob.tcommit%rowtype;
	first_mvt_id	int8;
	_commot		ob.tcommit%rowtype;
	cnt		int;
	mvt_id	int8;
BEGIN
	cnt := 0;
	FOR _commot IN SELECT * FROM ob.tcommit 
		WHERE did = draft_id  ORDER BY id ASC LOOP
		IF (cnt = 0) THEN
			first_commit := _commot;
		ELSE
			mvt_id := ob.fexecute_commit(prev_commit,_commot);
			if(mvt_id < 0) THEN RETURN mvt_id; END IF;
			if(cnt = 1) THEN first_mvt_id := mvt_id; END IF;
		END IF;
		prev_commit := _commot;
		cnt := cnt+1;
	END LOOP;
	IF( cnt <2 ) THEN
		RAISE NOTICE '[-30431] The draft % has less than two commits',draft_id;
		RETURN -30431;
	END IF;
	
	mvt_id := ob.fexecute_commit(_commot,first_commit);
	if(mvt_id < 0) THEN  RETURN mvt_id; END IF;
	-- sets did of movements to the first mvt.id
	UPDATE ob.tmvt set did=first_mvt_id 
	WHERE id>= first_mvt_id and id <= mvt_id;
	RETURN cnt;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.finsert_omegap(_nr int8,_nf int8) 
	RETURNS int AS $$
DECLARE
	t		int8;
	namef		text;
	namer		text;

BEGIN
	SELECT o.nf INTO t FROM ob.tomega o 
		WHERE o.nr = _nr and o.nf = _nf;
	IF (NOT FOUND) THEN
		SELECT name INTO namef FROM ob.tquality WHERE id=_nf;
		SELECT name INTO namer FROM ob.tquality WHERE id=_nr;
		INSERT INTO ob.tomega (nr,nf,name) 
			VALUES (_nr,_nf,namer || '/' || namef);
	ELSE
		-- it will be at the last position for candidates for update in market.fbatch_omega
		UPDATE ob.tomega SET updated=statement_timestamp()  
			WHERE nr = _nr and nf = _nf;
	END IF;
	RETURN 0;
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- PRIVATE called by ob.fomega_draft() while inserting a new bid
-- ret int = ob.finsert_omega_int(sid_src int8,sid_dst int8) used by ob.finsert_omega
-- sid_src,sid_dst are two commit.sid_dst of successive commmits of a draft
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.finsert_omega_int(sid_src int8,sid_dst int8) 
	RETURNS int AS $$
DECLARE
	_nr		int8;
	_nf		int8;
	_flux_src	int8;
	_flux_dst	int8;
	namef	text;
	namer	text;
	t		int8;
	_flags		int4 :=2;
	ret		int;

BEGIN
	SELECT nf,qtt INTO _nf,_flux_src FROM ob.tstock 
		WHERE id=sid_src;
	IF NOT FOUND THEN
		RAISE NOTICE '[-30409] stock % not found',sid_src;
		RETURN -30409;
	END IF;
	
	SELECT nf,qtt INTO _nr,_flux_dst FROM ob.tstock 
		WHERE id=sid_dst;
	IF NOT FOUND THEN
		RAISE NOTICE '[-30409] stock % not found',sid_dst;
		RETURN -30409;
	END IF;
	
	ret := ob.finsert_omegap(_nr,_nf);
	INSERT INTO ob.tlomega(nr,nf,qttr,qttf,flags) 
		VALUES (_nr,_nf,_flux_src,_flux_dst,_flags);
	RETURN 0;
	
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fomega_draft
--------------------------------------------------------------------------------
-- PRIVATE called by ob.finsert_bid_int

/* usage: 
	ret int = o
	(draft_id int8)
		
conditions:
	draft exists with more than 1 commit
action:
	inserts omega for a given draft

*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.fomega_draft(draft_id int8) 
	RETURNS int AS $$
DECLARE
	prev_commit	ob.tcommit%rowtype;
	first_commit	ob.tcommit%rowtype;
	_commot		ob.tcommit%rowtype;
	_flux_src	int8;
	_flux_dst	int8;
	cnt		int;
	err		int; 
BEGIN
	cnt := 0;
	FOR _commot IN SELECT * FROM ob.tcommit 
		WHERE did = draft_id  ORDER BY id ASC LOOP
		IF (cnt = 0) THEN
			first_commit := _commot;
		ELSE
			err := ob.finsert_omega_int(prev_commit.sid_dst,_commot.sid_dst);
			if(err <0) THEN
				RAISE INFO '[%] ob.finsert_omega_int1',err;
				RETURN err;
			END IF;
		END IF;
		prev_commit := _commot;
		cnt := cnt+1;
	END LOOP;
	IF( cnt <=1 ) THEN
		RAISE INFO '[-30428] The draft % has less than two commits',draft_id;
		RETURN -30428; 
	END IF;	
	err := ob.finsert_omega_int(_commot.sid_dst,first_commit.sid_dst);
	if(err <0) THEN
		RAISE INFO '[%] ob.finsert_omega_int2',err;
		RETURN err;
	END IF;
	RETURN cnt;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.finsert_omega
--------------------------------------------------------------------------------
-- PRIVATE called by ob.fread_omega(_dnr,_dnf).

/* usage: 
	ret int = ob.finsert_omega(sid_src int8,sid_dst int8,flux_src int8,flux_dst int8,_dnr int8,_dnf int8)
		(_dnf,_dnr) 		is the quality couple which was used to find this draft,
		(*src,*dst)		are two successive commits of a draft.
		
conditions:
	stock.id=sid_src exists
	stock.id=sid_dst exists
action:
	inserts a new lomega from two successive commits of a draft found. 
	the bit 0 of lomega.flags is set when (_dnf,_dnr) == (stock[sid_src].nf,stock[sid_dst].nf)

	primary := ( (_dnf,_dnr) == (stock[sid_src].nf,stock[sid_dst].nf) )
		
	ob.tlomega[_dnf,_dnr] is inserted with flags = primary

*/
--------------------------------------------------------------------------------

CREATE FUNCTION 
	ob.finsert_omega(sid_src int8,sid_dst int8,flux_src int8,flux_dst int8,_dnr int8,_dnf int8) 
	RETURNS int AS $$
DECLARE
	_nr		int8;
	_nf		int8;
	t		int8;
	namef	text;
	namer	text;
	_flags   	int4;
	ret		int;

BEGIN
	IF (sid_src is NULL) THEN _nf = _dnf;
	ELSE
		SELECT nf INTO _nf FROM ob.tstock 
			WHERE id=sid_src;
		IF NOT FOUND THEN
			RAISE NOTICE '[-30409] stock % not found',sid_src;
			RETURN -30409;
		END IF;
	END IF;
	
	IF (sid_dst is NULL) THEN _nr = _dnr;
	ELSE
		SELECT nf INTO _nr FROM ob.tstock WHERE id=sid_dst;
		IF NOT FOUND THEN
			RAISE NOTICE '[-30409] stock % not found',sid_dst;
			RETURN -30409;
		END IF;
	END IF;

	ret := ob.finsert_omegap(_nr,_nf); -- insert (_nr,_nf) record in ob.tomega
	
	IF(_nr=_dnr AND _nf=_dnf) THEN
		_flags := 1;
	ELSE 
		_flags := 0;
	END IF;
	
	INSERT INTO ob.tlomega (nr,nf,qttr,qttf,flags) 
		VALUES (_nr,_nf,flux_src,flux_dst,_flags);
	RETURN 0;
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fremove_das
--------------------------------------------------------------------------------
-- PRIVATE called by market.fdelete_bid
/* usage:
	mvt ob.tlmvt = ob.fremove_das(id_src int8)
	
	conditions:
		stock.id=id_src exists, it is a stock (type S)
		
	actions;
		for the stock stock.id=id_src
			stock.qtt -> account[own,nat]
		the stock is deleted
		the movement is NOT recorded (the owner is unchanged) but
	
	returns the movement with mvt.id=ret
	ret <0 if error
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.fremove_das(id_src int8) 
	RETURNS ob.tlmvt AS $$
DECLARE
	id_dst int8;
	stock ob.tstock%rowtype;
	id_mvt int8;
	mvt ob.tlmvt%rowtype;
BEGIN
	mvt.id := 0;
	SELECT s.* INTO stock FROM ob.tstock s 
		WHERE s.id=id_src and s.type='S';
	IF NOT FOUND THEN 
		RAISE NOTICE '[-30409] the stock % with type S was not found',id_src;
		mvt.id = -30409;
		RETURN mvt;
	END IF;
	SELECT id INTO id_dst FROM ob.tstock s 
		WHERE s.own=stock.own AND s.nf=stock.nf AND s.type='A' LIMIT 1;
	IF NOT FOUND THEN
		INSERT INTO ob.tstock (own,qtt,nf,type) 
		VALUES (stock.own,stock.qtt,stock.nf,'A') 
		RETURNING id INTO id_dst;
	ELSE 
		UPDATE ob.tstock SET qtt=qtt+stock.qtt 
			WHERE id=id_dst;
	END IF;

	mvt.src := id_src;mvt.own_src := stock.own;
	mvt.dst := id_dst;mvt.own_dst := stock.own;
	mvt.qtt := stock.qtt;  mvt.nat := stock.nf;

	DELETE FROM ob.tstock WHERE id=id_src;	
	RETURN mvt;
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.finsert_das
--------------------------------------------------------------------------------
-- PRIVATE
--	used by market.finsert_bid and ob.finsert_bid_int
/* usage:
	mvt ob.tlmvt = ob.finsert_das(stock_src ob.tstock,_qtt bigint,_type char)
		creates a stock of type=_type 
		returns the movement
	conditions:
		_type is S or D
		_qtt >0
		the stock_src stock_src.id=id_src exists, 
		stock_src.type=A or S
		stock_src.qtt >= _qtt
		
	actions;
		for the stock_src stock_src.id=id_src
			qtt moved from stock_src[id_src]-> NEW stock
		the stock_src is NOT deleted if qtt=0
		the movement is NOT recorded (the owner is unchanged)
	
	returns the movement
	or an exception
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.finsert_das(stock ob.tstock,_qtt bigint,_type char) 
	RETURNS ob.tlmvt AS $$
DECLARE
	id_dst int8;
	id_mvt int8;
	mvt ob.tlmvt%rowtype;
	_owned	bool;
BEGIN
	mvt.id := 0;
	IF stock.type='D' THEN
		RAISE LOG '[-30426] the stock[%].type should be A or S',stock.id;
		mvt.id := -30426;
		RETURN mvt;
	END IF;
	IF NOT (_type IN('D','S') AND (_qtt >0)) THEN
		RAISE  LOG '[-30430] the _type=% should be S or D and qtt > 0',_type;
		mvt.id := -30430;
		RETURN mvt;
	END IF;
	IF (stock.qtt < _qtt) THEN
		RAISE LOG '[-30408] the stock % has qtt=%,it is not big enough for % ',stock.id,stock.qtt,_qtt;
		mvt.id := -30408;
		RETURN mvt;
	END IF;	
	------------------------------------------------------------------------
	
	INSERT INTO ob.tstock (own,nf,qtt,type) 
		VALUES (stock.own,stock.nf,_qtt,_type) 
		RETURNING id INTO id_dst;
	IF NOT FOUND THEN
		RAISE LOG '[-30427] the stock could not be inserted'; 
		mvt.id := -30427;
		return mvt;
	END IF;

	UPDATE ob.tstock set qtt = stock.qtt - _qtt WHERE id = stock.id;
	--TODO  when the stock is empty where is it removed?
	mvt.id := 0;
	mvt.src := stock.id;mvt.own_src := stock.own;
	mvt.dst := id_dst;mvt.own_dst := stock.own;
	mvt.qtt := _qtt;  mvt.nat := stock.nf;
	RETURN mvt;
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- market.fdelete_bid_int
-- PRIVATE 
--------------------------------------------------------------------------------
CREATE FUNCTION 
	market.fdelete_bid_int(bid_id int8) RETURNS int AS $$
DECLARE
	noeud		ob.tnoeud%rowtype;
	_commot		ob.tcommit%rowtype;
	quality		text;
	mvt		ob.tlmvt%rowtype;
	cnt		int;
	ret		int;
	draft_id	int8;
BEGIN
	SELECT n.* INTO noeud FROM ob.tnoeud n WHERE n.id=bid_id;
	IF NOT FOUND THEN
		RAISE NOTICE '[-30403]the noeud % was not found',bid_id ;
		RETURN -30403;
	END IF;
	-- verifies the user owns the quality offered
	SELECT q.name INTO quality FROM ob.tstock s 
		INNER JOIN ob.tquality q on (q.id=s.nf) 
		WHERE s.id=noeud.sid and q.own =user ;
	IF NOT FOUND THEN 
		RAISE INFO '[-30413] The quality % does not exist or is not owned by user',quality;
		RETURN -30413;
	END IF;
	------------------------------------------------------------------------
	FOR draft_id IN SELECT c.did FROM ob.tcommit c 
		INNER JOIN ob.tdraft d ON (d.id=c.did)
		WHERE c.bid = bid_id and d.status='D' 
		GROUP BY c.did LOOP
		
		-- more than one commit can be found, but only one is enough to refuse the draft
		SELECT c.* INTO _commot FROM ob.tcommit c 
			WHERE c.did=draft_id LIMIT 1;
		ret := ob.frefuse_draft_int(_commot.did,_commot.wid);
		IF (ret < 0 ) THEN
			RAISE INFO '[%] Abort in ob.frefuse_draft_int(%,%)',ret,_commot.did,_commot.wid;
			RETURN ret;
		END IF;
		
	END LOOP;
	
	-- no draft reference this bid
	DELETE FROM ob.tnoeud WHERE id=bid_id;
	-- the stock S is deleted if no other bid reference it.
	SELECT count(id) INTO cnt FROM ob.tnoeud 
		WHERE sid=noeud.sid;
	if(cnt =0) THEN 
		mvt := ob.fremove_das(noeud.sid); -- the stock is removed and qtt goes back to the account
		IF (mvt.id < 0) THEN 
			RAISE INFO '[%] ob.fremoved_das(%) failed',mvt.id,noeud.sid;
			RETURN mvt.id;
		END IF;
	END IF;
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
CREATE FUNCTION ob.fdelete_draft(draft_id int8) RETURNS int AS $$
DECLARE
	_commot	ob.tcommit%rowtype;
	_stock ob.tstock%rowtype;
	_cnt integer;
	_qtt int8;
BEGIN
	-- empty stocks sid_src and sid_dst are deleted
	FOR _commot IN SELECT * from ob.tcommit 
		WHERE did = draft_id LOOP
		
		SELECT qtt INTO _qtt FROM ob.tstock 
			WHERE id = _commot.sid_dst AND TYPE='D';
		IF(NOT FOUND OR (_qtt != 0)) THEN
			RAISE INFO '[-30435] cannot delete the draft %',draft_id;
			RETURN -30435;
		END IF;
		-- a stock sid_dst is always referenced by a single commit
		UPDATE ob.tcommit SET sid_dst=NULL,bid=NULL 
			WHERE id=_commot.id;
		DELETE FROM ob.tstock WHERE id=_commot.sid_dst;
		-- this stock is D; it is not related to ob.tnoeud
			
		-- Several draft can refer to the same stockS, and the stockS can be non empty
		SELECT count(c.did) INTO _cnt 
			FROM ob.tcommit c 
			INNER JOIN ob.tstock s ON (c.sid_src=s.id) 
			WHERE s.qtt=0 AND _commot.sid_src=s.id; 
		IF (_cnt=1) THEN
			UPDATE ob.tcommit 
				SET sid_src=NULL,bid=NULL 
				WHERE id=_commot.id;
			DELETE FROM ob.tstock 
				WHERE id=_commot.sid_src;
			-- ob.tnoeud deleted by cascade
		-- ELSE other draft refers to the same stock, we must keep it even if it is empty
		END IF;
	END LOOP;
	
	DELETE FROM ob.tdraft d WHERE d.id=draft_id;
	-- ob.tcommit deleted by cascade
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.frefuse_draft_int
--------------------------------------------------------------------------------
-- PRIVATE
/* usage: 
	ret int = ob.frefuse_draft_int(draft_id int8,own_id int8) 
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.frefuse_draft_int(draft_id int8,own_id int8) 
	RETURNS int as $$
DECLARE
	draft 		ob.tdraft%rowtype;
	_commot	ob.tcommit%rowtype;
	res		int;
	_qtt		int8;
	stock		ob.tstock%rowtype;

BEGIN
	------------- controls ------------------------------------------------
	SELECT d.* INTO draft FROM ob.tdraft d WHERE d.id=draft_id;
	IF NOT FOUND THEN
		RAISE INFO '[-30420] the draft % was not found',draft_id ;
		RETURN -30420;
	END IF;
	
	res := ob.fread_status_draft(draft);
	IF(res < 0) THEN --draft status corrupted
		RETURN res;
	END IF;
	
	IF ((NOT(draft.status = 'D')) OR res!=0) THEN 
		RAISE INFO '[-30422] tried to refuse the draft % with the status % and res=%',draft_id,draft.status,res ;
		RETURN -30422;
	END IF;
	
	res := ob.fupdate_status_commits(draft_id,own_id,2,2); -- flags,mask
	IF (res < 0) THEN -- the owner was not found
		RETURN res;
	END IF;
	
	------------- refuse  --------------------------------------------------
	FOR _commot IN SELECT * FROM ob.tcommit 
		WHERE did = draft_id LOOP
		-- commit.sid_src <- commit.sid_dst
		SELECT qtt INTO _qtt FROM ob.tstock 
			WHERE id=_commot.sid_dst; 
		IF (NOT FOUND) THEN 
			RAISE INFO '[-30437] stockD % of draft % not found',_commot.sid_dst,draft_id;
			RETURN -30437;
		END IF;
		UPDATE ob.tstock SET qtt = qtt-_qtt 
			WHERE id=_commot.sid_dst; -- becomes empty
		UPDATE ob.tstock SET qtt = qtt+_qtt 
			WHERE id=_commot.sid_src;
	END LOOP;
	------------- delete draft --------------------------------------------
	res := ob.fdelete_draft(draft_id); -- stock_dst are empty
	 
	RETURN res;
END;
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.finsert_bid_int
--------------------------------------------------------------------------------
-- PRIVATE used by market.finsert_bid and market.finsert_sbid
/* usage: 
	nb_draft int8 = ob.finsert_bid_int(_sid int8,_qttprovided int8,_qttrequired int8,_qualityrequired text)

	conditions:
		the pivot stock.id=_sid exists.
		_omega > 0
		_qualityrequired exists
		
	action:
		tries to insert a bid with the stock _sid.
	
	returns nb_draft:
		the number of draft inserted.
		when nb_draft == -1, the insert was aborted after 3 retry
		nb_draft == -6 the pivot was not found
		-30403 qualityrequired not found
		-30406 omega <=0
		-30407 the pivot was not found or not deposited to user
*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.finsert_bid_int(_sid int8,_qttprovided int8,_qttrequired int8,_qualityrequired text) 
	RETURNS int AS $$
DECLARE
	cnt int;
	draft_id int8;
	commit_id int8;
	i	int8;
	r ob.tldraft%rowtype;
	stockb ob.tstock%rowtype;
	pivot ob.tstock%rowtype;
	mvt ob.tlmvt%rowtype;
	acc_id int8;
	version_cur int8;
	err int;
	_err int;
	first_commit int8;
	first_draft int8;
	_commot ob.tcommit%rowtype;
	time_begin timestamp;
	delai	int8;
	_nr	int8;
	_omega double precision;
	cnt2	int;
	_delay  int8;
	new_noeud_id int8;
BEGIN
	------------- controls ------------------------------------------------
	SELECT q.id INTO _nr FROM ob.tquality q 
		WHERE q.name = _qualityrequired;
	IF NOT FOUND THEN
		RAISE NOTICE '[-30405] the quality % was not found',_qualityrequired;
		RETURN -30405;
	END IF;

	SELECT s.* INTO pivot FROM ob.tstock s 
		WHERE s.id = _sid and s.type='S';
	IF NOT FOUND THEN
		RAISE NOTICE '[-30407] the pivot % was not found',_sid;
		RETURN -30407;
	END IF;
	IF(_qttrequired <= 0 ) THEN
		RAISE NOTICE '[-30414] _qttrequired % should be > 0',_qttrequired;
		RETURN -30414;
	END IF;
	IF(_qttprovided <= 0 ) THEN
		RAISE NOTICE '[-30415] _qttrprovided % should be > 0',_qttprovided;
		RETURN -30415;
	END IF;
	_omega := CAST(_qttprovided as double precision)/CAST(_qttrequired as double precision);
	IF(_omega <= 0.) THEN
		RAISE NOTICE '[-30406] omega % should be > 0',_omega;
		RETURN -30406;
	END IF;
	------------------------------------------------------------------------

	version_cur := ob.fcurrval_tdraft();
	cnt := 0;err := 0; first_commit :=0; first_draft := 0;
	time_begin := clock_timestamp(); err := 0;
	/*-- RAISE INFO 'ob.getdraft_get(%,%,%,%)',pivot.id,_omega,pivot.nf,_nr; */
	FOR r IN SELECT * FROM ob.getdraft_get(pivot.id,_omega,pivot.nf,_nr) LOOP
		/* -- RAISE INFO 'err %',r.ret_algo;	*/
		err := CAST(r.ret_algo as INT);
		IF (err != 0) THEN 
			RAISE NOTICE '[%] Error in ob.getdraft_get()',err;
			RETURN err;
		END IF;
	
		IF (cnt != (r.id+1)) THEN -- r.id starts from 0
			/* -- starts a new draft */
			cnt := cnt+1;
			IF(cnt != (r.id+1)) THEN -- should not append
				RAISE  NOTICE '[-30410] r.id sequence is not 0..N';
				RETURN -30410;
			END IF;
			IF(cnt !=1) THEN -- omega's of the previous draft are recorded 
				_err := ob.fomega_draft(draft_id); --records omegas of the previous draft
				if(_err <0) THEN
					RAISE NOTICE '[%] Error in ob.finsert_bid_int()',_err;
					RETURN _err;
				END IF;
			END IF;

			INSERT INTO ob.tdraft -- version_decision = NULL is the default
					(id,status,versionsg,nbsource,nbnoeud,cflags) 
				VALUES (version_cur+r.id,'D',r.versionsg,r.nbsource,r.nbnoeud,r.cflags)
				RETURNING id INTO draft_id;
			IF(first_draft = 0) THEN
				first_draft := draft_id;
			END IF; 	

		END IF;
		/* 					
		The version of the subgraph r.versionsg is defined as MAX(stock[].version) 
		for all stocks of the subgraph at the time the subgraph was formed.
			
		Since the subgraph contains the stock[r.sid] the condition:
			stock[r.sid].version > r.versionsg
		means the stock[r.sid] has been updated AFTER the draft was formed.
			
		*/				
		SELECT * INTO stockb FROM ob.tstock s WHERE s.id = r.sid;
		IF (NOT FOUND 
			or (stockb.qtt < r.fluxarrondi) 
			or (stockb.version > r.versionsg)) THEN
			
			err := -30411; /* when the stock used by the commit
			does not exist or not big enough, the draft is outdated */
			RETURN err;
		END IF;

		
		mvt := ob.finsert_das(stockb,r.fluxarrondi,'D'); -- stock_draft created
		/*
		-- if stockb[r.sid] becomes empty, it is not deleted,
		-- it will be when the draft is executed or refused
		-- the trigger updates stock.version to 'ob.tdraft_id_seq'= version_cur
		*/
		IF(mvt.id <0) THEN 
			_err := CAST(mvt.id AS INT);
			IF (_err = -30408) THEN
				RAISE NOTICE 'stock.qtt=% < fluxarrondi=%',stockb.qtt,r.fluxarrondi;
			END IF;
			RAISE NOTICE '[%] Error in ob.finsert_bid_int()',_err;
			return _err;
		END IF;
		
		/*-- RAISE NOTICE 'mvt % r.sid %,r.fluxarrondi %',mvt.id,r.sid,r.fluxarrondi;
		-- update ob.tstock set version = version_cur WHERE id=mvt.src;
		-- RAISE INFO 'commit % % % % % %',draft_id,r.bid,r.sid,mvt.dst,r.wid,r.flags;	*/			
		INSERT INTO ob.tcommit(did,bid,sid_src,sid_dst,wid,flags)
			VALUES (draft_id,r.bid,r.sid,mvt.dst,r.wid,r.flags) 
			RETURNING id INTO commit_id;
		
		IF(first_commit = 0) THEN 
			first_commit := commit_id;
		END IF;
			
	END LOOP;
	
	INSERT INTO ob.tnoeud (sid,omega,nr,nf,own,provided_quantity,required_quantity) 
		VALUES (pivot.id,_omega,_nr,pivot.nf,pivot.own,_qttprovided,_qttrequired)
		RETURNING id INTO new_noeud_id;
	
	
	IF(cnt != 0) THEN -- some draft were found
		-- RAISE NOTICE 'appel de ob.fomega_draft(%)',draft_id;
		
		_err := ob.fomega_draft(draft_id); -- TODO omega's of the last draft are recorded
		IF(_err <0) THEN
			RAISE NOTICE '[%] Error in ob.finsert_bid_int()',_err;
			RETURN _err;
		END IF;
		
		_delay := CAST(EXTRACT(microseconds FROM (clock_timestamp() - time_begin))/cnt AS INT8);
		UPDATE ob.tdraft SET delay = _delay WHERE id >= first_draft;
		
		
		UPDATE ob.tcommit  SET bid = new_noeud_id 
		WHERE   id >= first_commit and bid is NULL; -- sets the noeud.id 
		
		/* empty stocks are NOT deleted */
		
		SELECT setval('ob.tdraft_id_seq',version_cur+cnt) INTO version_cur;
	END IF;
	
	RETURN cnt;
END; 
$$ LANGUAGE PLPGSQL;

--------------------------------------------------------------------------------
-- ob.fread_omega
--------------------------------------------------------------------------------
-- PRIVATE used by market.fbatch_omega(commit_src ob.tcommit,tmpc_dst ob.tcommit)
/* usage: 
	error int ob.fread_omega(nr int8,nf int8)
conditions:
	_nr and _nf exist
actions:

*/
--------------------------------------------------------------------------------
CREATE FUNCTION 
	ob.fread_omega(_nr int8,_nf int8) 
	RETURNS int AS $$
DECLARE
	prem_r ob.tldraft%rowtype;
	der_r ob.tldraft%rowtype;
	r ob.tldraft%rowtype;
	cnt_draft int;
	ret int;
	_err int;
	qu int8;
	retry bool;
	_nrn text;
	_nfn text;
BEGIN
	SELECT q.name INTO _nrn FROM ob.tquality q 
		WHERE q.id = _nr;
	IF NOT FOUND THEN
		RAISE NOTICE '[-30402] the quality nr=% was not found',_nr;
		RETURN -30402;
	END IF;
	SELECT q.name INTO _nfn FROM ob.tquality q 
		WHERE q.id = _nf;
	IF NOT FOUND THEN
		RAISE  NOTICE '[-30402] the quality nf=% was not found',_nf;
		RETURN -30402;
	END IF;
	--
	cnt_draft := 0;
	<<DRAFT_LINES>>
	FOR r IN SELECT * FROM ob.getdraft_get(0,1.0,_nr,_nf) LOOP
		ret := CAST(r.ret_algo AS INT);
		IF(ret <0 ) THEN
			IF ( ret = -30144 ) THEN -- arc forbidden
				RAISE NOTICE '[%] Loop found for arc (Xoid,Yoid)=(%,%)',ret,r.bid,r.sid;
				_err := market.fdelete_bid_int(r.bid);
				IF(_err !=0) THEN
					RAISE NOTICE '[%] Error in ob.fread_omega()',_err;
				END IF;
				RETURN ret;
			END IF;
			RETURN ret;
		END IF;

		IF (r.cix = 0) THEN -- the first commit
			cnt_draft := cnt_draft + 1;
			IF (cnt_draft != 1) THEN -- the last commit of the last draft
				ret := ob.finsert_omega(der_r.sid,prem_r.sid,der_r.fluxarrondi,prem_r.fluxarrondi,_nr,_nf); 
				IF (ret < 0) THEN -- -30409 the stock was not found
					RETURN ret; 
				END IF;
			END IF;
			prem_r := r;

		ELSE
			ret := ob.finsert_omega(der_r.sid,r.sid,der_r.fluxarrondi,r.fluxarrondi,_nr,_nf); 
			IF (ret <0) THEN 
				RETURN ret; 
			END IF;
		END IF;
		der_r := r; 
	END LOOP DRAFT_LINES;
	-- 
	IF(cnt_draft != 0) THEN
		ret := ob.finsert_omega(der_r.sid,prem_r.sid,der_r.fluxarrondi,prem_r.fluxarrondi,_nr,_nf);
		IF (ret<0) THEN 
			RETURN ret; 
		END IF;
	END IF;
	
	RETURN 0;
END; 
$$ LANGUAGE PLPGSQL;
/*
dnUser:
	the name of a depository is the ssl_client_dn_field('commonName') 
	of it's certificate
dnquality:
	for a quality nameQuality owned by dnUser, it is:
		dnUser>nameQuality

Rules:
	A user can add or sub values only if he owns the quality of the value
	A user can accept/refuse draft only if he is the owner of some quality exchanged 
	A user can make a bid or sbid on values only if he owns the quality provided.
		
> Is there a way to run a pl/pgsql automatically at server startup ?
in your postgres startup script launch a session with `psql ... -c "some
sql commands"` or `psql ... -f somescript.sql` ... 

A role having USAGE granted for a LANGUAGE can create a FUNCTION.
By default, a function execution is granted to public:
BEGIN;
CREATE FUNCTION check_password(uname TEXT, pass TEXT) ... SECURITY DEFINER;
REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;
COMMIT;

GRANT page 1297
REVOKE page 1331

revoke all privileges on database test from public;
revoke all on datable test from noright;
grant connect on database test to noright;

Affiche les droits accordés aux relations
select relname,relacl from pg_class where relname like 'ob.%';

pour la fonction appelante
SECURITY DEFINER
grant to depositary;

pour toutes les fct du schema:
revoke execute on all functions in schema ob from public;

une fct d'un schema peut appeler la fct d'un autre schema,
	
*/
--------------------------------------------------------------------------------
-- SUBSCRIPTION, CERTIFICATE RENEWAL and USE'S QUOTAS
--------------------------------------------------------------------------------
CREATE TABLE ob.tuser (
	status INT default 0,
	crt_renewal text DEFAULT NULL,
	crt text DEFAULT NULL,
	dn text,
	cntbid int default 0,
	quotabid int,
	startcnt timestamp,
	created timestamp,
	updated timestamp,
	PRIMARY KEY (dn)
	
);
CREATE TRIGGER trig_befa_tuser BEFORE INSERT 
	OR UPDATE ON ob.tuser FOR EACH ROW 
	EXECUTE PROCEDURE ob.ftime_updated();
	
GRANT SELECT,UPDATE ON ob.tuser TO depositary,admin;
GRANT INSERT ON ob.tuser TO admin;
/* subscription process
admin runs:
	SELECT ob.fadduser(dn,10000);
the user connects.

certificate renewal process
When the certificate is too old, the user looks for a new certificate
whith the old certificate, runs:
	SELECT market.fcrt_start_renewal();
with the new certificate runs:
	SELECT ob.fgetuser(2);
with the old certificate runs:
	SELECT market.fcrt_read_renewal();
obtains a value dnIssuer:serialNumer of the new certificate, and compare this 
value to that of the new certificate. If the value is correct, runs:
	SELECT market.fcrt_accept_renewal(dnIssuer:serialNumer)

At any time between start and accept, 
	SELECT market.fcrt_accept_renewal();
abort the renewal process.
*/
--------------------------------------------------------------------------------
-- depositaries have dn without "." 
--------------------------------------------------------------------------------
CREATE FUNCTION ob.fadduser(_dn text,_quotabid int) RETURNS text AS $$
DECLARE
	_crt text;
	_status int;
BEGIN
	SELECT crt,status INTO _crt,_status FROM ob.tuser WHERE dn=_dn;
	IF FOUND THEN
		RAISE NOTICE 'Not inserted: The common name % is already used,with status %',_dn,_status;
		RETURN -1;
	END IF;
	IF (NOT _dn LIKE '%.%') THEN
		INSERT INTO ob.tuser (dn,quotabid,startcnt) VALUES (_dn,_quotabid,now());
		RAISE NOTICE 'The common name % is inserted',_dn;
		RETURN 0;
	ELSE
		RAISE NOTICE 'Not inserted: The common name % should not contain "."',_dn;
		RETURN -1;	
	END IF;

END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
GRANT EXECUTE ON FUNCTION ob.fadduser(_dn text,_quotabid int)  TO admin;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION market.fcrt_start_renewal() RETURNS INT AS $$
DECLARE
	_user text;
BEGIN
	
	_user := ob.fgetuser(1);
	UPDATE ob.tuser SET status=2 FROM ob.tuser WHERE dn=_user;
	RAISE NOTICE 'The certificate renewal procedure is now started';
	RAISE NOTICE 'You need to do the following:';
	RAISE NOTICE 'A) disconnect and reconnect with your new certificate and run:';
	RAISE NOTICE '	SELECT fgetuser(2);';
	RAISE NOTICE 'B) disconnect and reconnect with your old certificate';
	RAISE NOTICE '	and accept or refuse the new certificate';
	RAISE NOTICE 'D) disconnect and reconnect with your new certificate';
	RAISE NOTICE 'At any time you can abort the procedure by running with your old certificate:';
	RAISE NOTICE '	SELECT fcrt_abort_renewal();';
	RETURN 0;
	
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;
GRANT EXECUTE ON  FUNCTION market.fcrt_start_renewal() TO depositary;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION market.fcrt_read_renewal() RETURNS INT AS $$
DECLARE
	_crt_renewal text;
	_user text;
BEGIN
	
	_user := ob.fgetuser(2);
	SELECT crt_renewal INTO _crt_renewal FROM ob.tuser WHERE dn=_user;
	RAISE NOTICE 'The certificate renewal procedure is at step B)';
	RAISE NOTICE 'This function gave you the dnIssuer:serialNumber of a certificate that someone recorded';
	RAISE NOTICE 'Compare it carefully the dn of the issuer and the serial number of your new certificate';
	RAISE NOTICE 'If it is NOT your new certificate, run:';
	RAISE NOTICE '	SELECT fct_refuse_renewal()';
	RAISE NOTICE 'If you are absolutely shure it is yours, copy and paste the result of this function';
	RAISE NOTICE 'as parameter _dnIssuer:serialNumber_ surrounded by single quotes of: ';
	RAISE NOTICE '	SELECT fcrt_accept_renewal(_dnIssuer:serialNumber_)';
	RAISE NOTICE 'disconnect and reconnect with your new certificate';
	RETURN _crt_renewal;
	
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION market.fcrt_accept_renewal(_crt_renewal1 text) RETURNS INT AS $$
DECLARE
	_user text;
	_crt_renewal text;
	_res int;
BEGIN
	
	_user := ob.fgetuser(2);
	SELECT crt_renewal INTO _crt_renewal FROM ob.tuser WHERE dn=_user;
	IF(_crt_renewal != _crt_renewal1) THEN
		_res := market.fct_abort_renewal();
		RAISE NOTICE 'The certificate you entered "%"',_crt_renewal;
		RAISE NOTICE 'Is different from "%"',crt_renewal;
		RAISE NOTICE 'Someone else perhaps tried to take your identity';
		RETURN -1;
	END IF; 
	
	UPDATE ob.tuser SET crt=_crt_renewal WHERE dn=_user;
	UPDATE ob.tuser SET status=1,crt_renewal=NULL WHERE dn=_user;
	RAISE NOTICE 'Your new certificate is now confirmed';
	RAISE NOTICE 'Your can reconnect with your new certificate';
	RAISE NOTICE 'Your old certificate is now desabled';
	RETURN 0;
	
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION market.fct_abort_renewal() RETURNS INT AS $$
DECLARE
	_user text;
	_crt text;
BEGIN
	
	_user := ob.fgetuser(2);
	UPDATE ob.tuser SET status=1,crt_renewal=NULL WHERE dn=_user;
	RAISE NOTICE 'The certificate renewal procedure has been cancelled!';
	RETURN 0;
	
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION ob.fgetuser(_status_required int) RETURNS text AS $$
DECLARE
	_dn text;
	_crt text;
	_crt1 text;
	_status int;
BEGIN
	if (user='olivier') THEN return user;
	END IF;
	if(NOT (ob.ssl_is_used() AND ob.ssl_client_cert_present())) THEN
		RAISE EXCEPTION '[-30439] Client certificate required';
	END IF;
	
	_dn = ob.ssl_client_dn_field('commonName');
	_crt1 = ob.ssl_issuer_dn() || ':' || CAST(ob.ssl_client_serial() AS text);

	SELECT crt,status INTO _crt,_status FROM ob.tuser WHERE dn=_dn;
	IF NOT FOUND THEN
		RAISE EXCEPTION '[-30439] Client certificate required';
	END IF;
	
	IF (_status=0) THEN			
		UPDATE ob.tuser SET crt=_crt1,status=1 WHERE dn=_dn;
		RETURN _dn;
	END IF;
	
	IF(_status != _status_required) THEN
		RAISE EXCEPTION '[-30439] Client certificate required';
	END IF;
	
	IF (_status=2) THEN
		UPDATE ob.tuser SET crt_renewal=_crt1 WHERE dn=_dn;
		RAISE NOTICE 'Please disconnect and connect with your old certificate';
		RETURN '';
	END IF;
	
	IF (NOT _crt=_crt1) THEN
		RAISE EXCEPTION '[-30439] Client certificate required';
	END IF;
	RETURN _dn;	
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;

--------------------------------------------------------------------------------
-- 
--------------------------------------------------------------------------------
CREATE FUNCTION ob.fbidallowed(_dn text) RETURNS int AS $$
DECLARE
	_user ob.tuser%rowtype;
BEGIN
	if (user='olivier') THEN return 0; END IF;
	SELECT * INTO _user FROM ob.tuser WHERE dn=_dn;
	IF NOT FOUND THEN
		RAISE EXCEPTION 'internal error';
	END IF;
	IF(now() -__user.startcnt > cast('1 day' as interval)) THEN
		UPDATE ob.tuser SET startcnt = now(),cntbid=0 
			WHERE dn=_dn RETURNING * INTO _user;
	END IF;
	IF(_user.cntbid > _user.quotabid) THEN
		RAISE EXCEPTION 'Your quota is exhausted';
	END IF;
	UPDATE ob.tuser SET cntbid=cntbid+1 WHERE dn=_dn;
	RETURN 0;
END;
$$ LANGUAGE PLPGSQL SECURITY DEFINER;



revoke all on schema ob from public cascade;
grant usage on schema ob to market;
revoke execute on all functions in schema ob from public;
grant execute on all functions in schema ob to market;
grant select,update,insert,delete on all tables in schema ob to market;

revoke all on schema market from public cascade;
revoke execute on all functions in schema market from public;
grant usage on schema market to depositary;
grant execute on all functions in schema ob to depositary;
grant select on all tables in schema ob to depositary; -- includes views


